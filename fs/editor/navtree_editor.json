{
  "blocks": [
    {
      "type": "code",
      "output": "import {mut} from \"/lib/solid/monke.js\"\n    \nconst BACKGROUND = \"#0D1117\"\nconst M = mut({});\ndocument.M = M;\nconst defer = (fn, t = 200) => setTimeout(fn, t)\n\n// -------------\n// Solid Imports\n// -------------\nimport {\n\tbatch,\n\teach,\n\teff_on,\n\th,\n  \tmem,\n\tmounted,\n\tproduce,\n\trender,\n\tsig,\n\tstore,\n} from \"/lib/solid/monke.js\";\n\nimport { Keymanager } from \"/lib/keymanager.js\";\nimport { createEnvironment } from \"/lib/ts/ts.js\";\nimport { drag } from \"/lib/drag.js\"\nimport { createPanZoom } from \"/lib/panzoom/panzoom.js\"\n\n\n// -------------\n// Codemirror Imports\n// -------------\nimport * as cm from \"/lib/codemirror/codemirror.js\"\nconst {basicSetup,EditorView, Vim, vim} = cm\nconst { indentWithTab } = cm.commands\nconst { EditorState, StateField } = cm.state\nconst { keymap, showTooltip } = cm.view\nconst { toggleFold, foldAll,   HighlightStyle, syntaxHighlighting,  } = cm.language\nconst { javascript } = cm.lang_javascript\nconst { tags } = cm.lezer_higlight\nconst { lintGutter, linter, openLintPanel } = cm.lint\nconst { autocompletion, completeFromList } = cm.autocomplete\nlet t = tags\n\n// -------------\n// UTILITIES\n// -------------\n\nasync function post(url = \"\", body) {\n  try {\n  let f = await fetch(url, {\n    method: \"POST\",\n    headers: {\"Content-Type\": \"application/json\"},\n    body: JSON.stringify(body)\n  }).then((res) => res.json())\n  return f\n  }catch {\n  return null\n  }\n}\n\nlet CURRENT_PATH = sig(\"\");\nconst m = () => { return iframe_ref()?.contentDocument.M }\n\n// -------------\nlet iframe_ref = sig(null)\n\neff_on(iframe_ref, () => {\n\tif (iframe_ref()) {\n\t\tconsole.log(\"ref was set\", iframe_ref())\n\t\tconsole.log(\"SETTING EDITOR\")\n\t\tif (m()) m().EDITOR = editor\n\t}\n})\n\n// -------------\n\nconst uid = () => Math.random().toString(36).substring(7);\n\nconst throttle = (fn, delay) => {\n  \n\tlet timerFlag = null;\n\treturn (...args) => {\n\t\tif (timerFlag === null) {\n\t\t\tfn(...args);\n\t\t\ttimerFlag = setTimeout(() => timerFlag = null, delay);\n\t\t}\n\t};\n}\nfunction eval_code(code) {\n\treturn eval(`\"use strict\";(${code})`);\n}\n\n// =============\n// CORE\n// =============\nclass RendererList {\n\tconstructor() {\n\t\tconst [renderers, set_renderers] = store({});\n\t\tthis.renderers = renderers;\n\t\tthis.set_renderers = set_renderers;\n\t}\n\n\tregister(type, fn) {\n\t\tthis.set_renderers(type, fn);\n\t}\n\n\t/**\n\t * @param {name} string\n\t * @returns {() => View}\n\t */\n\tfind(type) {\n\t\tconst fn_str = this.renderers[type];\n\t\tconst fn = eval_code(fn_str);\n\t\tif (typeof fn == \"function\") return fn;\n\t\telse throw new Error(\"invalid renderer\");\n\t}\n}\n\nclass State {\n  constructor({ type, blocks, parent, cursor, id, tsserver }) {\n    const _blocks = blocks ? blocks : [];\n    const _type = type ? type : \"default\";\n    const _id = id ? id : uid();\n\n    const [model, update] = store({\n        blocks: _blocks,\n        output: \"\",\n    });\n\n    this.id = _id;\n    this.type = _type;\n    this.model = model;\n    this.tsserver = tsserver\n    this.update = (...args) => update(...args);\n    this.start = 0\n\n    this.parent = parent;\n    this.cursor = sig(cursor || -1);\n  }\n\n  get blocks() {\n      return this.model.blocks;\n  }\n\n  update_blocks(...args) {\n      return this.update(\"blocks\", ...args);\n  }\n\n  len() {\n      return this.model.blocks.length;\n  }\n\n  next() {\n      this.len() > this.cursor() + 1\n          ? this.cursor.set(this.cursor() + 1)\n          : null;\n          // : this.cursor.set(0);\n  }\n\n  prev() {\n      this.cursor() > 0\n          ? this.cursor.set(this.cursor() - 1)\n          : null\n          // : this.cursor.set(this.len() - 1);\n  }\n\n  write() {\n      const queue = this.model.blocks.map((comp) => comp.write);\n      let start = 0\n      const run = (code, index) => {\n          if (\"function\" == typeof code) {\n              this.update_blocks(index, produce((el) => {\n                  el.start = start\n                  code(el)\n                  start += el.output.length\n              }))\n          }\n      }\n\n      batch(() => {\n          queue.forEach(run)\n      });\n\n      this.output = this.model.blocks.map((e) => e.output).join(\"\");\n  }\n\n//***************************\n// --------------------------\n// Put these in a utility fn?\n// --------------------------\n//***************************\n\nfocus_on_pos(pos) {\n  let start = this.start\n  let found = false\n  this.blocks.forEach((block, i) => {\n    if (found) return\n    \n    // check \n    if (block.output.length + start > pos) {\n      // pos is contained in this block, pass focus_on_pos to block\n      // unfocus all blocks and focus this one\n      this.update_blocks(produce(blocks => {\n        blocks.forEach((block, ii) => {\n          if (i !== ii) {\n            if (block.focus) { if (block.onunfocus) block.onunfocus() }\n            \n            block.focus = false\n            block.active = false\n          } else {\n            this.cursor.set(i)\n            block.focus = true \n            \n            if (typeof block.focus_on_pos == \"function\") {\n              found = true\n              block.focus_on_pos(pos - this.start)\n            } \n              \n            else if (block.onfocus) {\n              block.onfocus()\n            }\n          }\n        })\n      }))\n\n      return\n    }\n    else start += block.output.length\n  })\n  \n}\n\n  async lint(from, to) {\n    if (!this.tsserver) { return this.parent.lint(from + this.start, to + this.start) }\n\n    let sem_diagnostics = await this.tsserver.semantic_diagnostics();\n    let syn_diagnostics = await this.tsserver.syntactic_diagnostics();\n\n    if (!Array.isArray(sem_diagnostics)) sem_diagnostics = []\n    if (!Array.isArray(syn_diagnostics)) syn_diagnostics = []\n    const diagnostics = [...sem_diagnostics, ...syn_diagnostics]\n    if (!diagnostics) return []\n\n    return diagnostics\n        .filter(d => d.start !== undefined && d.length !== undefined)\n        .map(d => {\n            if (d.code == 7006 || d.code == 7005) return\n            let severity = \"error\"\n\n            let f = d.start - from // if from < f, => f < 0 \n            let t = f + d.length\n\n            if (f < 0) { return }\n            if (d.start + d.length >= to) { return }\n\n            let message = d.messageText\n\n            return {\n                from: f,\n                to: t,\n                severity,\n                message\n            };\n        }).filter((e) => e != undefined);\n  };\n  \n  async find_definition(pos) {\n      if (!this.tsserver) {\n          // then send req to parent and add personal start\n          const c = this.parent.find_definition(pos + this.start)\n          return c\n      }\n\n      const quick = await this.tsserver.find_definition(pos);\n      if (!quick) { return null; }\n      return quick\n  }\n  async quick_info(pos) {\n      if (!this.tsserver) {\n          // then send req to parent and add personal start\n          const c = this.parent.quick_info(pos + this.start)\n          return c\n      }\n\n      const quick = await this.tsserver.quick_info(pos);\n      if (!quick) { return null; }\n      return quick\n  }\n\n  async completion(pos, ctx) {\n      if (!ctx) return null\n      if (!this.tsserver) {\n          // then send req to parent and add personal start\n          const c = this.parent.completion(pos + this.start, ctx)\n          return c\n      }\n\n      const completions = await this.tsserver.completion_at(pos);\n      if (!completions) { return null; }\n\n      let completList = completeFromList(\n          completions.entries.map((c, _) => {\n              return {\n                  type: c.kind,\n                  label: c.name,\n                  boost: 1 / parseInt(c.sortText),\n              }\n          })\n      )(ctx)\n\n      return completList\n  }\n\n  // TODO: Localstorage and reload?\n  load(path) {\n      fetch(\"/fs/\" + path).then((res) => res.json())\n          .then((res) => {\n              res.blocks\n                  ? this.update(\"blocks\", res.blocks)\n                  : console.log(\"no blocks\");\n              CURRENT_PATH.set(path);\n          });\n  }\n\n  // TODO: Implement saving functions in the editor itself -> next version\n  // TODO: Make a component for file directory editing and saving stuff\n  overwrite(path) {\n      console.log(\"overwriting\", path);\n\n      const body = {\n          content: JSON.stringify(this.model, null, 2),\n      };\n\n      fetch(\"/fs/\" + path, {\n          headers: { \"Content-Type\": \"application/json\" },\n          method: \"PUT\",\n          body: JSON.stringify(body),\n      });\n  }\n\n  create_new(path) {\n      const body = {\n          content: JSON.stringify(this.model, null, 2),\n      };\n      fetch(\"/fs/\" + path, {\n          headers: { \"Content-Type\": \"application/json\" },\n          method: \"POST\",\n          body: JSON.stringify(body),\n      });\n  }\n\n  save(path) {\n      fetch(\"/exists/\" + path).then((res) => res.json()).then((res) =>\n          res.exists ? this.overwrite(path) : this.create_new(path)\n      );\n  }\n\n  preview(path) {\n      // fix this\n      this.output_file(path).then((res) => {\n          window.location = \"/fs/\" + path;\n      });\n  }\n\n  output_file(path) {\n      const body = {\n          content: iframe(),\n      };\n\n      fetch(\"/fs/\" + path, {\n          headers: { \"Content-Type\": \"application/json\" },\n          method: \"PUT\",\n          body: JSON.stringify(body),\n      });\n  }\n}\n\nclass Tsserver {\n\tconstructor(file = \"\", browser = false) {\n\t\tthis.env = null\n\t\tthis.file = file\n\t\tthis.browser = browser\n\n\t\tif (this.browser) {\n\t\t\t//TODO: Turn into webworker later\n\t\t\tcreateEnvironment(\"console.log('hello world')\").then((e) => {\n\t\t\t\tthis.env = e;\n\t\t\t\t// add tsconfig.json\n\t\t\t\tthis.update_file(this.file)\n\t\t\t})\n\t\t}\n\t}\n  \n\tupdate_file(content) {\n\t\tif (!content || content.length == 0) return\n\t\tlet space_only = true\n\t\tcontent.split(\"\").forEach((c) => { if (c != \" \") space_only = false })\n\t\tif (space_only) return\n\n\t\tif (this.browser) {\n\t\t\tif (this.env) { this.env.updateFile(\"index.js\", content) }\n\t\t\telse this.file = content\n\t\t}\n\n\t\tfetch(\"/tsserver/update\", {\n\t\t\tmethod: \"POST\", body: JSON.stringify({ content }),\n\t\t\theaders: { \"Content-Type\": \"application/json\" }\n\t\t})\n\n\t}\n\n    async find_references(pos){\n      return post(\"/ts/findReferences\", {args: [pos]})\n        .then((res) => {\n          if (!res) return\n          console.log(\"got for\", pos)\n          console.log(\"definition\",res)\n          return res\n          if (res[0].definition && res[0].definition.fileName == \"index.js\")  return (res[0].definition.textSpan.start)\n          else return null\n        })\n    }\n\n  async find_definition(pos) {\n    let res = await this.find_references(pos)\n    console.log(\"definition\", res)\n    if (!res) return null\n    if (res[0].definition && res[0].definition.fileName == \"index.js\") return res[0].definition.textSpan.start\n    else return null\n    \n  }\n  \n    async quick_info(pos){\n      return await post(\"/ts/getQuickInfoAtPosition\", {args: [pos]}).then(async (res) => {\n        if (!res) return\n        if (res && res.displayParts){\n          let result = await post(\"/ts/displayPartsToString\", {args: [res.displayParts]})\n          let description = \"\"\n          res.documentation?.length \n            ? description += await post(\"/ts/displayPartsToString\", {args: [res.documentation]})\n            : null\n          console.log(\"returning\",result)\n          return result\n        }\n      })\n    }\n  \n\n\tasync completion_at(pos) {\n\t\tif (this.browser) {\n\t\t\tif (this.env) return this.env.languageService.getCompletionsAtPosition('index.js', pos)\n\t\t\telse return []\n\t\t}\n\n\t\ttry {\n\t\t\tconst res =\n\t\t\t\tawait fetch(\"/tsserver/completion_at\", {\n\t\t\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\t\t\tmethod: \"POST\", body: JSON.stringify({ pos })\n\t\t\t\t})\n\t\t\tlet ret = await res.json()\n\t\t\treturn ret\n\t\t} catch (err) {\n\t\t\treturn null\n\t\t}\n\t}\n\n\tasync semantic_diagnostics() {\n\t\tif (this.browser) {\n\t\t\tif (this.env) return this.env.languageService.getSemanticDiagnostics('index.js')\n\t\t\telse return []\n\t\t}\n\n\t\ttry {\n\t\t\tconst res = await fetch(\"/tsserver/semantic_diagnostics\")\n\t\t\tlet ret = await res.json()\n\t\t\treturn ret.content\n\t\t} catch (err) {\n\t\t\treturn []\n\t\t}\n\t\t// if (this.env) return this.env.languageService.getSemanticDiagnostics('index.js')\n\t\t// else return []\n\t}\n\n\tasync syntactic_diagnostics() {\n\t\tif (this.browser) {\n\t\t\tif (this.env) return this.env.languageService.getSyntacticDiagnostics('index.js')\n\t\t\telse return []\n\t\t}\n\n\t\ttry {\n\t\t\tconst res = await fetch(\"/tsserver/syntactic_diagnostics\")\n\t\t\tlet ret = await res.json()\n\t\t\treturn ret.content\n\n\t\t} catch (err) {\n\t\t\treturn []\n\t\t}\n\t}\n\n\n}\n\n//TODO: make this part of the editor...\nclass Positioner {\n\tconstructor(x, y, w, h, unit = \"v\", position = \"fixed\") {\n\t\tthis.x = sig(x || 0);\n\t\tthis.y = sig(y || 0);\n\t\tthis.w = sig(w || 0);\n\t\tthis.h = sig(h || 0);\n\n\t\tthis.unit = unit;\n\t\tthis.position = position;\n\n\t\tthis.style = mem(() => {\n\t\t\tconst v = this.unit == \"v\" ? \"vh\" : this.unit;\n\t\t\tconst h = this.unit == \"v\" ? \"vw\" : this.unit;\n\n\t\t\treturn `\n\t\t\t\tposition: ${this.position};\n\t\t\t\ttop: ${this.y() + v};\n\t\t\t\tleft: ${this.x() + h};\n\t\t\t\theight: ${this.h() + v};\n\t\t\t\twidth: ${this.w() + h};\n\t\t\t`;\n\t\t});\n\t}\n\n\tget css() {\n\t\treturn this.style;\n\t}\n}\n\n// Pass Editor into M -> so the live code in editor can change stuff in this editor.\nclass Editor {\n\t/**\n\t * @param {Object} EditorOpts \n\t * @param {State} EditorOpts.state \n\t * */\n\tconstructor({ state, components, renderer }) {\n\t\tif (!renderer) throw Error(\"Need a renderer\");\n\t\tthis.tsserver = new Tsserver()\n\t\tif (state) state.tsserver = this.tsserver\n\t\tthis.state = state ? state : new State({ type: \"RootGroup\", tsserver: this.tsserver });\n        this.iframe_pos = new Positioner(0, 0, 100, 100);\n\n\t\tthis.renderer = renderer;\n\t\tthis.renderers = components ? components : new RendererList();\n\t\tthis.positioner = new Positioner(0, 0, 100, 100);\n\n\t\tthis.live_output = sig(null)\n\t\tthis.output = mem(() => this.state.model.blocks.map((b) => b.output || \"\").join(\"\") || \"\")\n\n\n\t\teff_on(this.output, () => { this.tsserver.update_file(this.output()) })\n\n\t\teff_on(this.live_output, () => {\n\t\t\tif (this.live_output() && this.live_output() != null) {\n\t\t\t\tlet out = this.live_output()\n\t\t\t\tthis.tsserver.update_file(out)\n\t\t\t}\n\t\t})\n\t}\n\n\tregister(type, fn_str) {\n\t\tthis.renderers.register(type, fn_str);\n\t}\n\n  toggle_hide () {\n  // if positioner.x > 0 x = 0\n  // if positioner.x > 0 x = 0\n     console.log(\"trying to hide\", this.positioner.x())\n     if (this.positioner.x() > 0) this.positioner.x.set(0)\n     else {\n       console.log(\"setting x to 90\")\n       this.positioner.x.set(90)\n     }\n  }\n\n\tget css() {\n\t\treturn this.positioner.css\n\t}\n\n\tbind(element, setter) {\n\t\tconst render = this.renderer;\n\t\tconst component = render(element, this.state);\n\n\t\tsetter((el) => {\n\t\t\tObject\n\t\t\t\t.entries(component)\n\t\t\t\t.forEach(([key, value]) => el[key] = value);\n\t\t});\n\n\t\treturn component.render;\n\t}\n\n\trender() {\n\t\tconst setter = (fn) => this.state.update(produce(fn));\n\t\treturn this.bind(this.state, setter);\n\t}\n}\n\n//TODO: make these available at user runtime\nfunction state_utils(state) {\n  const find_focused = () => state.blocks.find((e) => e.focus);\n  const find_active = () => state.blocks.find((e) => e.active);\n\n  function move_child (index, direction) {\n    state.update_blocks(\n      produce((el) => {\n        if (!el[index + direction] || !el[index]) return;\n        let temp = el[index];\n        el[index] = el[index + direction];\n        el[index + direction] = temp;\n      }),\n    );\n  };\n\n  \n  function is_scrollable(el) {\n\treturn el.scrollHeight > el.clientHeight;\n  }\n \n  \n  function find_offset_to_parent(el, parent) {\n\treturn [el.offsetLeft - parent.offsetLeft, el.offsetTop - parent.offsetTop];\n  }\n\n  function get_scrollabe_parent(el) {\n  \tlet found_parent = false;\n  \tlet element = el;\n  \n  \tdo {\n  \t\telement = element.parentElement;\n  \n  \t\tif (!element) return;\n  \t\tif (is_scrollable(element)) found_parent = true;\n  \t} while (!found_parent && element);\n  \n  \treturn element;\n  }\n\n\n  const scroll_to_active = () => {\n    let active = find_active()\n    if (!active) return\n    let id = \"block-\"+active.id\n    \n    let el = document.getElementById(id);\n    let parent = get_scrollabe_parent(el);\n    if (parent) {\n        let [x, y] = find_offset_to_parent(el, parent);\n        parent.scrollTo({ top: y - 50,\n                        // behavior: \"smooth\" \n                        });\n    }\n  }\n\n\n  const set_current_active = () => {\n      if (!state.blocks[state.cursor()]) return;\n      state.update_blocks(state.cursor(), \"active\", true);\n      state.update_blocks((_, i) => i != state.cursor(), \"active\", false);\n  };\n\n  const set_current_focus = () => {\n      if (!state.blocks[state.cursor()]) return;\n      const current = state.blocks[state.cursor()];\n      state.update_blocks(state.cursor(), \"focus\", true);\n      if (current.onfocus) current.onfocus();\n  };\n\n  const unfocus_current = () => {\n      const current = find_focused(state);\n      if (!current) return;\n      if (current.handle_unfocus) current.handle_unfocus()\n      else {\n          state.update_blocks((e) => e.focus, \"focus\", false);\n          if (current.onunfocus) current.onunfocus();\n      }\n  };\n\n\treturn {\n      find_focused,\n      find_active,\n      scroll_to_active,\n      set_current_active,\n      set_current_focus,\n      unfocus_current,\n      move_child,\n\t};\n}\n\nconst child_style = (child, pos) => {\n\tconst border_is = mem(() => child.active && !child.focus);\n\tconst shadow_is = mem(() => child.focus);\n\n\tconst border = mem(() => border_is() ? \"border: 1px solid red\" : \"\");\n\tconst box_shadow = mem(() =>\n\t\tshadow_is() ? \"box-shadow: 0 0 25px 15px rgba(0,0,0,.1)\" : \"\"\n\t);\n    const additional = mem(() => `\n          background: #ffffff88; \n          position: absolute;\n          top: ${child.top()}px;\n          left: ${child.left()}px;\n          padding: 3px;\n          padding-top: 25px;\n          width: ${child.width()}px;\n          max-height: ${child.height()}vh;\n    `)\n\n\treturn mem(() => [border(), box_shadow(), additional()].join(\";\"));\n};\n\nconst add_widget = (opts, state) => {\n\tif (!opts.id) opts.id = uid()\n\tstate.update_blocks(produce((e) => e.push(opts)));\n\n\teditor.state.write()\n}\n\n// =============\n// Root Renderer\n// =============\n/**\n * @param {State} state\n */\nfunction RootCanvasRenderer(el, state) {\n\tif (!state) throw Error(\"NEED STATE\")\n\n\tconst blocks = el.blocks || [];\n\tstate = state || new State({ blocks });\n\n\t// add these to state as prototype?\n\tconst {\n      set_current_focus,\n      set_current_active,\n      find_focused,\n      find_active,\n      unfocus_current,\n      scroll_to_active,\n      move_child\n\t} = state_utils(state);\n\n\teff_on(state.cursor, () => {\n      set_current_active()\n      // scroll_to_active()\n    });\n  // bring active in scroll\n\n\n  const bind = (child, index) => {\n    if (!child) return;\n    const item = editor.renderers.find(child.type);\n    if (!(typeof item == \"function\")) return;\n\n    const setter = (...args) => state.update_blocks(index(), ...args);\n    const controller = { set_self: setter, state: state };\n    const component = item(child, index, controller);\n    let left = sig(child.drag_x ? child.drag_x : Math.random() * 100)\n    let top = sig(child.drag_y ? child.drag_y : Math.random() * 100)\n  \n  // height is in px\n    let width = sig(child.drag_w ? child.drag_w : 600)\n  // height is in vh\n    let height = sig(child.drag_h ? child.drag_h : 80)\n    \n    \n    let onref = (e) => { \n      setTimeout(() => drag(e, {set_left: left.set, set_top: top.set}), 10)\n    }\n\n    setter(produce((block) => {\n        block.left = left\n        block.top = top\n        block.width = width\n        block.height = height\n      \n        Object\n            .entries(component)\n            .forEach(([key, value]) =>{\n              if (key == \"write\") {\n                console.log(\"writing\")\n                block[key] = (el) => {\n                  el.drag_x = left()\n                  el.drag_y = top()\n                  \n                  value(el)\n                }\n              }else {\n                block[key] = value;\n              }\n            })\n    }));\n  \n    const style = child_style(child);\n    return h(\"div.child\", { ref: onref,style: style, id: \"block-\" + child.id }, component.render);\n  };\n  \n  // increase cur left\n  // increase cur top\n  const inc_cur_left = () => {\n    let current = find_active()\n    if (!current) return\n    current.left?current.left.set(current.left() + 10):null\n  }\n  \n  const dec_cur_left = () => {\n    let current = find_active()\n    if (!current) return\n    current.left?current.left.set(current.left() - 10):null\n  }\n  \n  const inc_cur_top = () => {\n    let current = find_active()\n    if (!current) return\n    current.top?current.top.set(current.top() + 10):null\n  }\n  \n  const dec_cur_top = () => {\n    let current = find_active()\n    if (!current) return\n    current.top?current.top.set(current.top() - 10):null\n  }\n  \n  const dec_cur_width = () => {\n    let current = find_active()\n    if (!current) return\n    current.width?current.width.set(current.width() - 10):null\n  }\n  \n  const inc_cur_width = () => {\n    let current = find_active()\n    if (!current) return\n    current.width?current.width.set(current.width() + 10):null\n  }\n  \n  const dec_cur_height = () => {\n    let current = find_active()\n    if (!current) return\n    current.height?current.height.set(current.height() - 10):null\n  }\n  \n  const inc_cur_height = () => {\n    let current = find_active()\n    if (!current) return\n    current.height?current.height.set(current.height() + 10):null\n  }\n\n\tconst keys = new Keymanager();\n\n\n\tkeys.on(\"Escape\", unfocus_current);\n\tkeys.on(\"Enter\", set_current_focus);\n\tkeys.on(\"shift+c\", (_) => add_widget({ type: \"code\" }, state));\n\tkeys.on(\"shift+s\", (_) => add_widget({ type: \"save-component\" }, state));\n\tkeys.on(\"shift+p\", (_) => add_widget({ type: \"custom\" }, state));\n\tkeys.on(\"cmd+shift+l\", (_) => add_widget({ type: \"load-component\" }, state));\n\tkeys.on(\"shift+g\", (_) => add_widget({ type: \"group\" }, state));\n\tkeys.on(\"ctrl+s\", (_) => state.write());\n\tkeys.on(\"j\", (_) => state.next());\n\tkeys.on(\"k\", (_) => state.prev());\n    keys.on(\"shift+j\", (_) => inc_cur_top())\n    keys.on(\"shift+k\", (_) => dec_cur_top())\n    keys.on(\"shift+l\", (_) => inc_cur_left())\n    keys.on(\"shift+ArrowRight\", (_) => inc_cur_width())\n    keys.on(\"shift+ArrowLeft\", (_) => dec_cur_width())\n    keys.on(\"shift+ArrowDown\", (_) => inc_cur_height())\n    keys.on(\"shift+ArrowUp\", (_) => dec_cur_height())\n  \n    keys.on(\"alt+shift+ArrowUp\",  (_) => move_child(state.cursor(), -1))\n    keys.on(\"alt+shift+ArrowDown\", (_) => move_child(state.cursor(), 1))\n  \n    keys.on(\"shift+h\", (_) => dec_cur_left())\n  \n    keys.on(\"cmd+e\", () => editor.toggle_hide())\n\tconst handle_keys = (e) => {\n\t\tconst focused = find_focused();\n\n\t\tif (focused && e.key != \"Escape\") {\n\t\t\tif (focused.onkeydown) focused.onkeydown(e);\n\t\t\treturn;\n\t\t}\n\n\t\tkeys.event(e);\n\t};\n\n\tconst write = (el) => {\n\t\tstate.write();\n\t\tlet output = state.blocks.map((child) => child.output).join(\"\\n\");\n\t\tel.output = output;\n\t\tel.blocks = state.blocks;\n\t};\n\n    let panzoom\n    let parent_ref = (e) => {\n      setTimeout(() =>  panzoom = createPanZoom(e, {}) , 100)\n    }\n  \n    const Render = () => h(\"div.group\",{ref: parent_ref}, () => each(() => state.blocks, bind))\n  \n\n\treturn {\n      // HERE: Add panzoom\n\t\trender: Render,\n\t\tonkeydown: handle_keys,\n\t\twrite: (el) => write(el),\n\t};\n}\n\n\nconst state = new State({\n\tblocks: [{\n      id: \"tingipungi\",\n\t\ttype: \"code\",\n      output: \"console.log('Hello world')\"\n}]\n})\n\nconst editor = new Editor({ renderer: RootCanvasRenderer, state });\n\n/**\n * @typedef {Object} View\n *\n * @property {(el) => void} write\n * @property {() => any[] | any} render\n *\n * @property {() => void} [onkeydown]\n * @property {() => void} [onfocus]\n * @property {() => void} [onunfocus]\n */\nwindow.onload = () => {\n\twindow.addEventListener(\"keydown\", (e) => {\n\t\tif (editor.state.model.onkeydown) {\n\t\t\teditor.state.model.onkeydown(e);\n\t\t}\n\t});\n};\n\n// Document as known issues\nconst f = \"/\";\nconst iframe = mem(() =>\n\t`<script type=\"module\"> \n        const SOURCE_PATH = \"${CURRENT_PATH()}\"\n        ${editor.state.blocks.map((e) => e.output).join(\"\\n\")}\n    <${f}script>`\n);\n\neff_on(iframe, () => defer(function() {\n\tconsole.log(\"Hey iframe was changed\")\n\tif (m()) m().EDITOR = editor\n}, 500))\n\nconst Root = () => {\n\tconst iframe_style = editor.iframe_pos.css;\n\tconst editor_style = mem(() => \"overflow-y: scroll;\" + editor.css());\n    const style = `\n      html {\n        font-size: 14.5px;\n      }\n      ::-webkit-scrollbar {display: none;}\n      @font-face {\n\t\tfont-family: 'DiatypeMono';\n\t\tsrc: url('/fs/fonts/diatype_mono.ttf') format('truetype');\n    \t}\n      \n      * {\n        -ms-overflow-style: none;  /* IE and Edge */\n        scrollbar-width: none;  /* Firefox */\n        font-family: \"DiatypeMono\";\n      }\n\n      .child {\n        max-height: 95vh;\n        overflow-y: scroll;\n      }\n\n      input[type=\"text\"] {\n        all: unset;\n        border: 1px white solid;\n        background: black;\n      }\n      \n      button {\n        all: unset;\n        cursor: pointer;\n        padding: 2px;\n        font-size: .8em;\n        color: white;\n        background: black;\n        border: 1px white solid;\n      }\n      \n      iframe {\n        all: unset;\n      }\n      \n      body {\n\t\tbackground:${BACKGROUND};\n        color: white;\n      }\n      \n      .group {\n        position: absolute;\n        top: 0;\n        left: 0;\n        background: #ff008844;\n        width: 500vw;\n        height: 500vh;\n      }\n    `\n\n\treturn h(\"div\", [\n        h(\"style\", style),\n\t\th(\"iframe.iframe\", { ref: iframe_ref.set, srcdoc: iframe, style: iframe_style }),\n\t\th(\"div.editor\", { style: editor_style }, editor.render()),\n\t]);\n};\n\n\n// ------------------------\n// SLIDER ELEMENT\n// ------------------------\nfunction slider(state){\n  let val = sig(state.value ? state.value : 0)\n  let output = mem(() => `M.slider = ${val()};`)\n  eff_on(val, () => {\n    console.log(\"sliding\", m(), val())\n    if (m()) m().slider = val() \n  })\n  \n  const renderer = () => {\n    return  h(\"div\", \n      h(\"input\", {\n        type: \"range\",\n        oninput: (e) => val.set(e.target.value)  }\n     ), h(\"p\", \"Value: \", val)\n    )\n  }\n\n  const write = (el) => {\n    el.output = output()\n    el.value = val()\n  }\n  \n  return {\n    render: renderer,\n    write: write\n  }\n}\neditor.register(\"slider\", slider.toString())\n\n// -----------------------\n// SAVE ELEMENT\n// ------------------------\nfunction save_editor(state) {\n  let path = sig(state.path ? state.path : \"\")\n  let save = () => editor.state.save(path())\n  const renderer = () => h(\"div\", [\n    h(\"input\", {type: \"text\",\n                id: \"input-\"+state.id,\n                value: path,\n                oninput: (e) => path.set(e.target.value)}),\n    h(\"button\",{onclick: save}, \"OVERWRITE\")\n  ])\n\n  return {\n    render: renderer,\n    write: (el) => {el.path = path();el.output = \"\"},\n    onfocus: () => document.getElementById(\"input-\"+state.id).focus(),\n    onunfocus: () => document.getElementById(\"input-\"+state.id).blur()\n  }\n}\neditor.register(\"save-component\", save_editor.toString())\n  \n// -----------------------\n// LOAD ELEMENT\n// ------------------------\nfunction load_editor(state) {\n  console.log(\"path: \", state.path)\n  let path = sig(state.path ? state.path : \"\")\n  let load = () => editor.state.load(path())\n  let onkeydown = (e) => e.key == \"Enter\" ? load() : null\n  \n  const renderer = () => h(\"div\", [\n    h(\"input\", {type: \"text\",\n                id: \"input-\"+state.id,\n                value: path,\n                onkeydown: onkeydown,\n                oninput: (e) => path.set(e.target.value)}),\n    \n    h(\"button\",{onclick: load}, \"load\")\n  ])\n\n  return {\n    render: renderer,\n    write: (el) => {el.path = path();el.output = \"\"},\n    onfocus: () => document.getElementById(\"input-\"+state.id).focus(),\n    onunfocus: () => document.getElementById(\"input-\"+state.id).blur()\n  }\n}\neditor.register(\"load-component\", load_editor.toString())\n  \n// -----------------------\n// Editor Sizer\n// ------------------------\nfunction editor_sizer(state) {\n  let size = sig(state.size ? state.size : \"100\")\n  // let set_size = eff_on(size,() => {\n  //   if (size() < 20) return\n  //   let e_w = parseInt(size())\n  //   editor.positioner.w.set(e_w)\n  //   editor.iframe_pos.x.set(e_w)\n  //   editor.iframe_pos.w.set(100-e_w)\n  // })\n  \n  const renderer = () => h(\"div\", [ h(\"h1\", \"NOT SUPPORTING THIS\") ])\n\n  return {\n    render: renderer,\n    write: (el) => {el.size = size();el.output = \"\"},\n    onfocus: () => document.getElementById(\"input-\"+state.id).focus(),\n    onunfocus: () => document.getElementById(\"input-\"+state.id).blur()\n  }\n}\neditor.register(\"editor_sizer\", editor_sizer.toString())\n\n// ------------------------\n// Custom Renderer\n// ------------------------\n  \nfunction custom_renderer(state, i, c) {\n  if (state.renderer) return eval_code(state.renderer)(state, i, c)\n    \n  const code = mem(() => state?.renderer \n    ? state?.renderer \n    :  custom_renderer.toString())\n\n  const id = uid();\n  let save, focus, focus_on_pos;\n\n  Vim.defineEx(\"write\", \"w\", () => editor.state.write());\n\n  const render = () => {\n      mounted(() => {\n          let extensions = []\n          const cm_editor = make_code_mirror(code(), id, extensions);\n          focus = () => setTimeout(() => cm_editor.focus(), 100);\n          save = function(el) {\n            \n              // TODO: add \"\\n\" only when not already added... \n              // TODO: Also mirro mechanism where else doc is accessed.\n              const text = cm_editor.state.doc.toString() \n              el.output = \"\"\n              el.focused = cm_editor.hasFocus;\n              el.renderer = text;\n              el.cursor = cm_editor.state.selection.ranges[0].from;\n          };\n\n          defer(function() {\n              if (state.cursor && state.focused) {\n                  const selection = { anchor: state.cursor, head: state.cursor };\n                  cm_editor.focus();\n                  cm_editor.dispatch({ selection });\n              }\n          });\n      });\n      return h(\"div\", { class: \"editor-\" + id });\n  };\n\n  // TODO: COMPONENT: template object representation\n  // should have icons for things and have intellisense...\n  return ({\n      render: render,\n      onfocus: () => focus(),\n      write: (...args) => save(...args),\n  });\n}\n\neditor.register(\"custom\", custom_renderer.toString())\n\n// ------------------------\n// GROUP Renderer\n// ------------------------\n/**\n * @typedef {Object} Controller\n * @property {State} state\n *\n */\n\n/**\n * @param {Controller} c \n */\nfunction GroupRenderer(el, i, c,) {\n\t// new state\n\tlet state = new State({ blocks: el.blocks || [], parent: c.state, id: el.id })\n\n\t// add these to state as prototype?\n\tconst {\n\t\tset_current_focus,\n\t\tset_current_active,\n\t\tfind_focused,\n\t\tunfocus_current,\n\t} = state_utils(state);\n\n\teff_on(state.cursor, set_current_active);\n\n\tconst _unfocus = () => {\n\t\t// if none in focus unfocus self, else just forward to unfocus current\n\t\tlet focused = find_focused()\n\t\tif (!focused) c.set_self(\"focus\", false)\n\t\telse unfocus_current()\n\t}\n\n\n\tconst bind = (child, index) => {\n\t\tif (!child) return;\n\t\tconst item = editor.renderers.find(child.type);\n\t\tif (!(typeof item == \"function\")) return;\n\n\t\tconst setter = (...args) => state.update_blocks(index(), ...args);\n\t\tconst controller = { set_self: setter, state: state };\n\t\tconst component = item(child, index, controller);\n\n\t\tsetter(produce((block) => {\n\t\t\tObject\n\t\t\t\t.entries(component)\n\t\t\t\t.forEach(([key, value]) => block[key] = value);\n\t\t}));\n\n\t\tconst style = child_style(child);\n\t\treturn h(\"div\", { style: style }, component.render);\n\t};\n\n\tconst keys = new Keymanager();\n\n\tkeys.on(\"Enter\"     , set_current_focus);\n  \n\tkeys.on(\"j\"         , (_)=>state.next());\n\tkeys.on(\"k\"         , (_)=>state.prev());\n  \n\tkeys.on(\"shift+c\" , (_)=>add_widget({ type: \"code\" }, state));\n\tkeys.on(\"shift+g\" , (_)=>add_widget({ type: \"group\" }, state));\n\tkeys.on(\"ctrl+s\"  , (_)=> state.write());\n\n\tconst handle_keys = (e) => {\n\t\tconst focused = find_focused();\n\n\t\tif (focused && e.key != \"Escape\") {\n\t\t\tif (focused.onkeydown) focused.onkeydown(e);\n\t\t\treturn;\n\t\t}\n\n\t\tkeys.event(e);\n\t};\n\n\tconst write = (el) => {\n\t\tstate.write();\n\t\tlet output = state.blocks.map((child) => child.output).join(\"\");\n\t\t//TODO : FUCKING FIX THIS\n\t\tstate.start = el.start\n\t\tel.output = output;\n\t\tel.blocks = state.blocks;\n\t};\n\n\n\treturn {\n      render: () =>\n          h(\"div.group\", () => each(() => state.blocks, bind)),\n      onkeydown: handle_keys,\n      write: (el) => write(el),\n      handle_unfocus: _unfocus,\n      focus_on_pos: state.focus_on_pos\n\t};\n}\n\neditor.register(\"group\", GroupRenderer.toString())\n\n\n\n\n",
      "active": false,
      "focus": false,
      "start": 0,
      "focused": false,
      "cursor": 24171,
      "drag_x": 1296.4725016957686,
      "drag_y": 1076.5029233305836
    },
    {
      "type": "code",
      "id": "t0gxe9",
      "start": 32585,
      "focused": false,
      "output": "\n// ------------------------\n// CODEMIRROR ELEMENT\n// ------------------------\nfunction code_element(state, index, control) {\n\tconst code = mem(() => state?.output ? state?.output : \"\");\n\n\t// only used for syncing with tsserver\n\tconst live_code = sig()\n\tconst id = uid();\n\tlet save, focus, focus_on_pos;\n\n\tVim.defineEx(\"write\", \"w\", () => editor.state.write());\n\tVim.defineEx(\"cm\", \"cm\", (e) => console.log(e));\n  /*\n  // to make zc and zm for folds\n    Vim.defineAction(\"ArenaGoFile\", (cm) => {\n      console.log(\"ArenaGoFile\", cm);\n      \n      let [from, to] = [\n        view.state.selection.ranges[0].from,\n        view.state.selection.ranges[0].to,\n      ];\n      \n      let f = view.state.sliceDoc(from, to);\n      \n      if (link_is_block(f)) {\n        let block_id = extract_block_id(f);\n        window.location.href = host + \"/blocks/\" + block_id + offline;\n      }\n      console.log(from, to);\n      console.log(f);\n    });\n\n\n    Vim.mapCommand(\"gf\", \"action\", \"ArenaGoFile\", {}, { context: \"visual\" });\n  */\n\n\tconst live_output = mem(() => {\n\t\tif (state.focus) {\n\t\t\tlet code_map = {}\n\t\t\tcode_map[state.id] = live_code()\n\n\t\t\tconst get_state_code_and_map = (state, map) => {\n\t\t\t\tlet id = state.id\n\t\t\t\tlet code = state.blocks\n\t\t\t\t\t.map((block) => map[block.id]\n\t\t\t\t\t\t? map[block.id]\n\t\t\t\t\t\t: block.output\n\t\t\t\t\t\t\t? block.output\n\t\t\t\t\t\t\t: \"\")\n\t\t\t\t\t.join(\"\")\n\n\t\t\t\tmap[id] = code\n\t\t\t\treturn code\n\t\t\t}\n\n\t\t\tlet parent = control.state\n\t\t\tlet full_code = \"\"\n\n\t\t\t// check if control.state\n\t\t\twhile (parent) {\n\t\t\t\t// console.log('checknig', parent)\n\t\t\t\tfull_code = get_state_code_and_map(parent, code_map)\n\t\t\t\tparent = parent.parent\n\t\t\t}\n\n\t\t\treturn full_code\n\t\t}\n\t\telse return null\n\t})\n\n\teff_on(live_output, () => {\n\t\tif (live_output()) editor.live_output.set(live_output())\n\t\telse editor.live_output.set(null)\n\t})\n\n\t// codemirro on change extension\n\n\tconst render = () => {\n      mounted(() => {\n\n       const cursorTooltipBaseTheme = EditorView.baseTheme({\n        \".cm-tooltip.cm-tooltip-cursor\": {\n          backgroundColor: \"#66b\",\n          color: \"white\",\n          border: \"none\",\n          padding: \"2px 7px\",\n          borderRadius: \"4px\",\n          \"& .cm-tooltip-arrow:before\": {\n            borderTopColor: \"#66b\"\n          },\n          \"& .cm-tooltip-arrow:after\": {\n            borderTopColor: \"transparent\"\n          }\n        }\n      }) \n\n\n      let def = sig(\"\")\n      let dom_ref = undefined\n      let hover = sig(true)\n      let definition_pos = sig(null)\n        \n      function get_cursor_tooltips (_state)  {\n         return _state.selection.ranges\n          .map(range => {\n            \n            let line = _state.doc.lineAt(range.head)\n            \n                // *****************************\n                // TODO: Throttle this, runs too many times \n                // *****************************\n\n\n            if(hover()){\n              let start = state.start ? state.start : 0\n              let p = start+range.head\n              \n              control.state.quick_info(p).then((res) => {\n                if (res) dom_ref.textContent = res\n              })\n            }\n            \n            return {\n              pos: range.head,\n              above: true,\n              strictSide: true,\n              arrow: true,\n              create: () => {\n                let dom = document.createElement(\"div\")\n                \n                dom.className = \"cm-tooltip-cursor\"\n                dom.textContent = def()\n                dom.style.display = hover() ? \"\" : \"none\"\n                dom_ref = dom\n                return { dom }\n              }\n            }\n          })[0]\n        \n      }\n      const cursorTooltipField = StateField.define({\n        create: get_cursor_tooltips,\n      \n        update: function(tooltips, tr) {\n          if (!tr.docChanged && !tr.selection && !hover()) return tooltips\n          return get_cursor_tooltips(tr.state)\n        },\n        \n        provide: f => hover() ? showTooltip.compute([f], state => state.field(f)) : null\n      })\n\n      function tooltip () {return  [cursorTooltipField, cursorTooltipBaseTheme]}\n\n          let extensions = [\n              tooltip(),\n              linter(() => {\n                  let start = state.start ? state.start : 0\n                  let end = start + live_code().length\n                  return control.state.lint(start, end)\n              }),\n            \n              keymap.of([\n                  {\n                    key: \"Mod-Shift-i\",\n                    run: () =>  {\n                      hover.set(!hover())\n                      if (dom_ref) dom_ref.style.display = hover() ? \"\" : \"none\"\n                    }\n                  },\n                \n                  {\n                    key: \"Mod-Shift-u\",\n                  // get references from editor for cur position, then tell \n                  // editor to focus there\n                    run: (e) =>  {\n                      let start = state.start ? state.start : 0\n                      control\n                        .state\n                        .find_definition(e.state.selection.ranges[0].head + start)\n                        .then((pos) => {\n                          if (pos) editor.state.focus_on_pos(pos)\n                        })\n                    }\n                  },\n              ]),\n\n              autocompletion({\n                  activateOnTyping: true,\n                  maxRenderedOptions: 20,\n                  override: [async (ctx) => {\n                      let { pos } = ctx\n                      let start = state.start ? state.start : 0\n                      let completion = await control.state.completion(pos + start, ctx)\n                      return completion\n                  }],\n              }),\n\n              EditorView.updateListener.of(throttle((e) => live_code.set(e.state.doc.toString() + \"\\n\"), 100))]\n\n          const cm_editor = make_code_mirror(code(), id, extensions);\n          focus = () => setTimeout(() => cm_editor.focus(), 100);\n\n          save = function(el) {\n              // TODO: add \"\\n\" only when not already added... \n              // TODO: Also mirro mechanism where else doc is accessed.\n              const text = cm_editor.state.doc.toString() + \"\\n\"\n              console.log(\"text\", text, \"start\", el.start);\n              el.focused = cm_editor.hasFocus;\n              el.output = text;\n              el.cursor = cm_editor.state.selection.ranges[0].from;\n          };\n\n        focus_on_pos = (pos) => {\n          console.log(\"cm asked to focus on\", pos)\n          let start = state.start ? state.start : 0\n          console.log(\"cm will focus on\", pos - start)\n          cm_editor.dispatch({selection:  {anchor: pos - start , head: pos - start}})\n          console.log(\"dispatched focus on\", pos - start)\n          focus()\n        }\n          defer(function() {\n              if (state.cursor && state.focused) {\n                  const selection = { anchor: state.cursor, head: state.cursor };\n                  cm_editor.focus();\n                  cm_editor.dispatch({ selection });\n              }\n          });\n      });\n      return h(\"div\", { class: \"editor-\" + id });\n\t};\n\n\t// TODO: COMPONENT: template object representation\n\t// should have icons for things and have intellisense...\n\treturn ({\n      render: render,\n      onfocus: () => focus(),\n      write: (...args) => save(...args),\n      focus_on_pos: (pos) => focus_on_pos(pos)\n\t});\n}\neditor.register(\"code\", code_element.toString());\n\n// ------------------------\n// CODEMIRROR UTILS\n// ------------------------\nfunction make_code_mirror(source, id, extensions) {\n\tconst element = document.querySelector(\".editor-\" + id);\n\tconst state = {\n\t\tdoc: source,\n\t\textensions: [\n\t\t\tvim(),\n\t\t\tjavascript(),\n          \n\t\t\tbasicSetup,\n\t\t\ttheme,\n          \n\t\t\tkeymap.of([\n                indentWithTab,\n                {\n                  key: \"Mod-e\",\n                  run: () =>  toggleFold(editor)\n                },\n                {\n                  key: \"Mod-shift-e\",\n                  run: () =>  foldAll(editor)\n                },\n\t\t\t\t{\n\t\t\t\t\tkey: \"Escape\",\n\t\t\t\t\trun: () => {\n\t\t\t\t\t\teditor.contentDOM.blur();\n\t\t\t\t\t\twindow.getSelection()?.removeAllRanges();\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]),\n\t\t\t...extensions,\n\t\t],\n\t};\n\n\tconst editor = new EditorView({\n\t\tparent: element,\n\t\tstate: EditorState.create(state),\n\t});\n\n\treturn editor;\n}\n\n\n\n",
      "cursor": 0,
      "active": false,
      "focus": false,
      "drag_x": 2275.345697392181,
      "drag_y": 1066.765896094001
    },
    {
      "type": "code",
      "id": "geuvga",
      "start": 40940,
      "focused": false,
      "output": "\nconst createTheme = ({ variant, settings, styles }) => {\n\tconst theme = EditorView.theme(\n\t\t{\n\t\t\t// eslint-disable-next-line @typescript-eslint/naming-convention\n\t\t\t\"&\": {\n\t\t\t\tbackgroundColor: settings.background,\n\t\t\t\tcolor: settings.foreground,\n\t\t\t},\n\t\t\t\".cm-editor.cm-focused\": {\n\t\t\t\toutline: \"none\",\n\t\t\t},\n\t\t\t\".cm-content\": {\n\t\t\t\tcaretColor: settings.caret,\n\t\t\t},\n\t\t\t\".cm-cursor, .cm-dropCursor\": {\n\t\t\t\tborderLeft: \"2px solid\" + settings.caret,\n\t\t\t},\n\t\t\t\"&.cm-focused .cm-selectionBackgroundm .cm-selectionBackground, .cm-content ::selection\":\n\t\t\t{\n\t\t\t\tbackgroundColor: settings.selection,\n\t\t\t},\n\t\t\t\".cm-activeLine\": {\n\t\t\t\tbackgroundColor: settings.lineHighlight,\n\t\t\t},\n\t\t\t\".cm-gutters\": {\n\t\t\t\tbackgroundColor: settings.gutterBackground,\n\t\t\t\tcolor: settings.gutterForeground,\n\t\t\t},\n            \"&.cm-focused .cm-fat-cursor\": {\n              background: settings.caret,\n              \n            },\n\t\t\t\".cm-activeLineGutter\": {\n\t\t\t\tbackgroundColor: settings.lineHighlight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdark: variant === \"dark\",\n\t\t},\n\t);\n\n\tconst highlightStyle = HighlightStyle.define(styles);\n\tconst extension = [theme, syntaxHighlighting(highlightStyle)];\n\n\treturn extension;\n};\n\nconst theme = createTheme({\n\tvariant: \"dark\",\n\tsettings: {\n\t\tbackground: BACKGROUND,\n\t\tforeground: \"white\",\n\t\tcaret: \"brown\",\n\t\tselection: \"#ffffff26\",\n\t\tgutterBackground: \"#fcfcfc22\",\n\t\tgutterForeground: \"#8a919922\",\n\t\tlineHighlight: \"#8a919922\",\n\t},\n\tstyles: [\n\t\t{\n\t\t\ttag: t.comment,\n\t\t\tcolor: \"#ffffff66\",\n\t\t},\n\t\t{\n\t\t\ttag: t.string,\n\t\t\tcolor: \"#A5D6FE\",\n\t\t},\n\t\t{\n\t\t\ttag: t.regexp,\n\t\t\tcolor: \"#4cbf99\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.number, t.bool, t.null],\n\t\t\tcolor: \"#A5D6FE\",\n\t\t},\n\t\t{\n\t\t\ttag: t.variableName,\n\t\t\tcolor: \"white\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.definitionKeyword, t.modifier],\n\t\t\tcolor: \"#FF7B72\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.keyword, t.special(t.brace)],\n\t\t\tcolor: \"#FF7B72\",\n\t\t},\n\t\t{\n\t\t\ttag: t.operator,\n\t\t\tcolor: \"#77BDFA\",\n\t\t},\n\t\t{\n          tag: t.separator,\n          color: \"white\",\n\t\t},\n\t\t{\n          tag: t.punctuation,\n          color: \"white\"\n\t\t},\n\t\t{\n          tag: [t.definition(t.propertyName), t.function(t.variableName)],\n          color: \"white\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.className, t.definition(t.typeName)],\n\t\t\tcolor: \"Orange\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.tagName, t.typeName, t.self, t.labelName],\n\t\t\tcolor: \"white\",\n\t\t},\n\t\t{\n\t\t\ttag: t.angleBracket,\n\t\t\tcolor: \"#55b4d480\",\n\t\t},\n\t\t{\n\t\t\ttag: t.attributeName,\n\t\t\tcolor: \"#F66BAC\",\n\t\t},\n\t],\n});\n\nrender(Root, document.body);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "cursor": 0,
      "active": false,
      "focus": false,
      "drag_x": 2930.679526509297,
      "drag_y": 1244.5519598843027
    },
    {
      "type": "load-component",
      "id": "40oxq5",
      "start": 43411,
      "path": "",
      "output": "",
      "active": false,
      "focus": false,
      "drag_x": 1458.9571417835818,
      "drag_y": 2123.3720525582567
    },
    {
      "type": "save-component",
      "id": "zri8um",
      "start": 43411,
      "path": "editor/canvas.json",
      "output": "",
      "active": true,
      "focus": true,
      "drag_x": 1466.9065836556088,
      "drag_y": 2052.632722311828
    },
    {
      "type": "editor_sizer",
      "id": "t0njv5",
      "start": 43411,
      "size": "51",
      "output": "",
      "active": false,
      "focus": false,
      "drag_x": 3856.858412962674,
      "drag_y": 1242.497343761742
    },
    {
      "type": "code",
      "id": "p313n",
      "start": 43411,
      "focused": false,
      "output": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "cursor": 0,
      "active": false,
      "focus": false,
      "drag_x": 3657.660925657684,
      "drag_y": 1759.7370272365827
    },
    {
      "type": "editor_sizer",
      "id": "mkyf1t",
      "start": 43434,
      "drag_x": 2861.05884174667,
      "drag_y": 571.560235366987,
      "size": "100",
      "output": "",
      "active": false,
      "focus": false
    },
    {
      "type": "load-component",
      "id": "j5nwde",
      "start": 43434,
      "drag_x": 53.36599572290544,
      "drag_y": 23.918254185231536,
      "path": "",
      "output": "",
      "active": false,
      "focus": false
    }
  ],
  "output": ""
}