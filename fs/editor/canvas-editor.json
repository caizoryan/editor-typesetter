{
  "blocks": [
    {
      "type": "code",
      "output": "import {mut} from \"/lib/solid/monke.js\"\n    \nconst M = mut({});\ndocument.M = M;\nconst defer = (fn, t = 200) => setTimeout(fn, t)\n\n// -------------\n// Solid Imports\n// -------------\nimport {\n\tbatch,\n\teach,\n\teff_on,\n\th,\n  \tmem,\n\tmounted,\n\tproduce,\n\trender,\n\tsig,\n\tstore,\n} from \"/lib/solid/monke.js\";\n\nimport {MD} from \"/lib/md.js\"\n\nimport { Keymanager } from \"/lib/keymanager.js\";\nimport { createEnvironment } from \"/lib/ts/ts.js\";\nimport { drag } from \"/lib/drag.js\"\nimport { createPanZoom } from \"/lib/panzoom/panzoom.js\"\n\n// -------------\n// Codemirror Imports\n// -------------\nimport * as cm from \"/lib/codemirror/codemirror.js\"\nconst {basicSetup,EditorView, Vim, vim} = cm\nconst { indentWithTab } = cm.commands\nconst { EditorState, StateField } = cm.state\nconst { keymap, showTooltip } = cm.view\nconst { toggleFold, foldAll,   HighlightStyle, syntaxHighlighting,  } = cm.language\nconst { javascript } = cm.lang_javascript\nconst { css } = cm.lang_css\nconst { tags } = cm.lezer_higlight\nconst { lintGutter, linter, openLintPanel } = cm.lint\nconst { autocompletion, completeFromList } = cm.autocomplete\nlet t = tags\n\n\n// -------------\n// constants\n// -------------\n\nconst curtain = sig(true)\nconst GROUPBG = mem(() => curtain() ? \"#ffbb0088\": \"#ffffff22\")\nconst BACKGROUND = \"#eeea\"\nconst FOREGROUND = \"grey\"\nlet through = sig(false)\n\n\n// -------------\n// UTILITIES\n// -------------\n\nasync function post(url = \"\", body) {\n  try {\n  let f = await fetch(url, {\n    method: \"POST\",\n    headers: {\"Content-Type\": \"application/json\"},\n    body: JSON.stringify(body)\n  }).then((res) => res.json())\n  return f\n  }catch {\n  return null\n  }\n}\n\nlet CURRENT_PATH = sig(\"\");\nconst m = () => { return iframe_ref()?.contentDocument.M }\n\n// -------------\nlet iframe_ref = sig(null)\n\neff_on(iframe_ref, () => {\n\tif (iframe_ref()) { if (m()) m().EDITOR = editor }\n})\n\n// -------------\n\nconst uid = () => Math.random().toString(36).substring(7);\n\nconst throttle = (fn, delay) => {\n  \n\tlet timerFlag = null;\n\treturn (...args) => {\n\t\tif (timerFlag === null) {\n\t\t\tfn(...args);\n\t\t\ttimerFlag = setTimeout(() => timerFlag = null, delay);\n\t\t}\n\t};\n}\nfunction eval_code(code) {\n\treturn eval(`\"use strict\";(${code})`);\n}\n\n// =============\n// CORE\n// =============\nclass RendererList {\n\tconstructor() {\n\t\tconst [renderers, set_renderers] = store({});\n\t\tthis.renderers = renderers;\n\t\tthis.set_renderers = set_renderers;\n\t}\n\n\tregister(type, fn) {\n\t\tthis.set_renderers(type, fn);\n\t}\n\n\t/**\n\t * @param {name} string\n\t * @returns {() => View}\n\t */\n\tfind(type) {\n\t\tconst fn_str = this.renderers[type];\n\t\tconst fn = eval_code(fn_str);\n\t\tif (typeof fn == \"function\") return fn;\n\t\telse throw new Error(\"invalid renderer\");\n\t}\n}\n\nclass State {\n  constructor({ type, blocks, parent, cursor, id, tsserver, properties }) {\n    const _blocks = blocks ? blocks : [];\n    const _properties = properties ? properties : {};\n    const _type = type ? type : \"default\";\n    const _id = id ? id : uid();\n\n    const [model, update] = store({\n        blocks: _blocks,\n        output: \"\",\n        properties: _properties\n    });\n\n    this.id = _id;\n    this.type = _type;\n    this.model = model;\n    this.tsserver = tsserver\n    this.update = (...args) => update(...args);\n    \n    /** @type {Array<Function>}*/\n    this.write_fn = []\n    this.start = 0\n\n    this.parent = parent;\n    this.cursor = sig(cursor || -1);\n  }\n\n  get blocks() {\n      return this.model.blocks;\n  }\n\n  update_blocks(...args) {\n      return this.update(\"blocks\", ...args);\n  }\n\n  update_properties(...args){\n      return this.update(\"properties\", ...args);\n  }\n\n  register_write(fn){\n    this.write_fn.push(fn)\n  }\n\n  len() {\n      return this.model.blocks.length;\n  }\n\n  next() {\n      this.len() > this.cursor() + 1\n          ? this.cursor.set(this.cursor() + 1)\n          : null;\n          // : this.cursor.set(0);\n  }\n\n  prev() {\n      this.cursor() > 0\n          ? this.cursor.set(this.cursor() - 1)\n          : null\n          // : this.cursor.set(this.len() - 1);\n  }\n\n  write() {\n      const queue = this.model.blocks.map((comp) => comp.write);\n      let start = 0\n      const run_fn = fn => (code, index) => {\n          if (\"function\" == typeof code) {\n              fn(index, produce((el) => {\n                  el.start = start\n                  code(el)\n                  start += el.output.length\n              }))\n          }\n      }\n    \n      const run_fnn = (code) => {\n          if (\"function\" == typeof code) {\n              this.update_properties(produce((el) => {\n                  console.log(\"running?\")\n                  code(el)\n              }))\n          }\n      }\n\n      batch(() => {\n          queue.forEach(run_fn(this.update_blocks.bind(this)))\n          this.write_fn.forEach(run_fnn)\n      });\n    \n      this.output = this.model.blocks.map((e) => e.output).join(\"\");\n  }\n\n  //***************************\n  // --------------------------\n  // Put these in a utility fn?\n  // --------------------------\n  //***************************\n  focus_on_pos(pos) {\n    let that = this\n    \n    \n    let start = that.start\n    let found = false\n    let f_i = null\n    \n    that.blocks.forEach((block, i) => {\n      if (found) return\n      \n      // check \n      if (block.output.length + start > pos) {\n        f_i = i\n        found = true\n        return\n      }\n        \n      else start += block.output.length\n    })\n\n    if (found){\n        // pos is contained in this block, pass focus_on_pos to block\n        that.update_blocks(produce(blocks => {\n          \n        // unfocus all blocks and focus this one\n          blocks.forEach((block, ii) => {\n            \n            // not these blocks\n            if (f_i !== ii) {\n              if (block.focus) { if (block.onunfocus) block.onunfocus() }\n              block.focus = false\n              block.active = false\n            } \n            \n            // this is the block\n            else {\n              that.cursor.set(f_i)\n              block.focus = true \n              // TODO: Changed this hopefully works still\n              // if this doesn't work put it back in below if block.\n              found = true\n\n              // ---------------------\n              // handles focusing\n              // ---------------------\n              if (typeof block.focus_on_pos == \"function\") {\n                block.focus_on_pos(pos - that.start)\n              } \n              else if (block.onfocus) {\n                block.onfocus()\n              }\n              \n            }\n            \n          })\n        }))\n  \n    }\n    \n  }\n\n  async lint(from, to) {\n    if (!this.tsserver) { return this.parent.lint(from + this.start, to + this.start) }\n\n    let sem_diagnostics = await this.tsserver.semantic_diagnostics();\n    let syn_diagnostics = await this.tsserver.syntactic_diagnostics();\n\n    if (!Array.isArray(sem_diagnostics)) sem_diagnostics = []\n    if (!Array.isArray(syn_diagnostics)) syn_diagnostics = []\n    const diagnostics = [...sem_diagnostics, ...syn_diagnostics]\n    if (!diagnostics) return []\n\n    return diagnostics\n        .filter(d => d.start !== undefined && d.length !== undefined)\n        .map(d => {\n            if (d.code == 7006 || d.code == 7005) return\n            let severity = \"error\"\n\n            let f = d.start - from // if from < f, => f < 0 \n            let t = f + d.length\n\n            if (f < 0) { return }\n            if (d.start + d.length >= to) { return }\n\n            let message = d.messageText\n\n            return {\n                from: f,\n                to: t,\n                severity,\n                message\n            };\n        }).filter((e) => e != undefined);\n  };\n  \n  async find_definition(pos) {\n      if (!this.tsserver) {\n          // then send req to parent and add personal start\n          const c = this.parent.find_definition(pos + this.start)\n          return c\n      }\n\n      const quick = await this.tsserver.find_definition(pos);\n      if (!quick) { return null; }\n      return quick\n  }\n  \n  async quick_info(pos) {\n      if (!this.tsserver) {\n          // then send req to parent and add personal start\n          const c = this.parent.quick_info(pos + this.start)\n          return c\n      }\n\n      const quick = await this.tsserver.quick_info(pos);\n      if (!quick) { return null; }\n      return quick\n  }\n\n  async completion(pos, ctx) {\n      if (!ctx) return null\n      if (!this.tsserver) {\n          // then send req to parent and add personal start\n          const c = this.parent.completion(pos + this.start, ctx)\n          return c\n      }\n\n      const completions = await this.tsserver.completion_at(pos);\n      if (!completions) { return null; }\n\n      let completList = completeFromList(\n          completions.entries.map((c, _) => {\n              return {\n                  type: c.kind,\n                  label: c.name,\n                  boost: 1 / parseInt(c.sortText),\n              }\n          })\n      )(ctx)\n\n      return completList\n  }\n\n  // TODO: Localstorage and reload?\n  load(path) {\n    console.log(\"lOADDEd\")\n      fetch(\"/fs/\" + path).then((res) => res.json())\n          .then((res) => {\n              if ( res.blocks ){\n                this.update(\"blocks\", res.blocks)\n                if (res.properties) this.update(\"properties\", res.properties)\n              }\n                \n              else { console.log(\"no blocks\"); }\n            \n              CURRENT_PATH.set(path);\n          });\n  }\n\n  // TODO: Implement saving functions in the editor itself -> next version\n  // TODO: Make a component for file directory editing and saving stuff\n  overwrite(path) {\n      console.log(\"overwriting\", path);\n      console.log(\"props\", this.model.properties);\n\n      const body = {\n          content: JSON.stringify(this.model, null, 2),\n      };\n\n      fetch(\"/fs/\" + path, {\n          headers: { \"Content-Type\": \"application/json\" },\n          method: \"PUT\",\n          body: JSON.stringify(body),\n      });\n  }\n\n  create_new(path) {\n      const body = {\n          content: JSON.stringify(this.model, null, 2),\n      };\n      fetch(\"/fs/\" + path, {\n          headers: { \"Content-Type\": \"application/json\" },\n          method: \"POST\",\n          body: JSON.stringify(body),\n      });\n  }\n\n  save(path) {\n      fetch(\"/exists/\" + path).then((res) => res.json()).then((res) =>\n          res.exists ? this.overwrite(path) : this.create_new(path)\n      );\n  }\n\n  preview(path) {\n      // fix this\n      this.output_file(path).then((res) => {\n          window.location = \"/fs/\" + path;\n      });\n  }\n\n  output_file(path) {\n      const body = {\n          content: iframe(),\n      };\n\n      fetch(\"/fs/\" + path, {\n          headers: { \"Content-Type\": \"application/json\" },\n          method: \"PUT\",\n          body: JSON.stringify(body),\n      });\n  }\n}\n\nclass Tsserver {\n\tconstructor(file = \"\", browser = false) {\n\t\tthis.env = null\n\t\tthis.file = file\n\t\tthis.browser = browser\n\n\t\tif (this.browser) {\n\t\t\t//TODO: Turn into webworker later\n\t\t\tcreateEnvironment(\"console.log('hello world')\").then((e) => {\n\t\t\t\tthis.env = e;\n\t\t\t\t// add tsconfig.json\n\t\t\t\tthis.update_file(this.file)\n\t\t\t})\n\t\t}\n\t}\n  \n\tupdate_file(content) {\n\t\tif (!content || content.length == 0) return\n\t\tlet space_only = true\n\t\tcontent.split(\"\").forEach((c) => { if (c != \" \") space_only = false })\n\t\tif (space_only) return\n\n\t\tif (this.browser) {\n\t\t\tif (this.env) { this.env.updateFile(\"index.js\", content) }\n\t\t\telse this.file = content\n\t\t}\n\n\t\tfetch(\"/tsserver/update\", {\n\t\t\tmethod: \"POST\", body: JSON.stringify({ content }),\n\t\t\theaders: { \"Content-Type\": \"application/json\" }\n\t\t})\n\n\t}\n\n    async find_references(pos){\n      return post(\"/ts/findReferences\", {args: [pos]})\n        .then((res) => {\n          if (!res) return\n          return res\n          if (res[0].definition && res[0].definition.fileName == \"index.js\")  return (res[0].definition.textSpan.start)\n          else return null\n        })\n    }\n\n  async find_definition(pos) {\n    let res = await this.find_references(pos)\n    if (!res) return null\n    if (res[0].definition && res[0].definition.fileName == \"index.js\") return res[0].definition.textSpan.start\n    else return null\n    \n  }\n  \n    async quick_info(pos){\n      return await post(\"/ts/getQuickInfoAtPosition\", {args: [pos]}).then(async (res) => {\n        if (!res) return\n        if (res && res.displayParts){\n          let result = await post(\"/ts/displayPartsToString\", {args: [res.displayParts]})\n          let description = \"\"\n          res.documentation?.length \n            ? description += await post(\"/ts/displayPartsToString\", {args: [res.documentation]})\n            : null\n          return result\n        }\n      })\n    }\n  \n\n\tasync completion_at(pos) {\n\t\tif (this.browser) {\n\t\t\tif (this.env) return this.env.languageService.getCompletionsAtPosition('index.js', pos)\n\t\t\telse return []\n\t\t}\n\n\t\ttry {\n\t\t\tconst res =\n\t\t\t\tawait fetch(\"/tsserver/completion_at\", {\n\t\t\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\t\t\tmethod: \"POST\", body: JSON.stringify({ pos })\n\t\t\t\t})\n\t\t\tlet ret = await res.json()\n\t\t\treturn ret\n\t\t} catch (err) {\n\t\t\treturn null\n\t\t}\n\t}\n\n\tasync semantic_diagnostics() {\n\t\tif (this.browser) {\n\t\t\tif (this.env) return this.env.languageService.getSemanticDiagnostics('index.js')\n\t\t\telse return []\n\t\t}\n\n\t\ttry {\n\t\t\tconst res = await fetch(\"/tsserver/semantic_diagnostics\")\n\t\t\tlet ret = await res.json()\n\t\t\treturn ret.content\n\t\t} catch (err) {\n\t\t\treturn []\n\t\t}\n\t\t// if (this.env) return this.env.languageService.getSemanticDiagnostics('index.js')\n\t\t// else return []\n\t}\n\n\tasync syntactic_diagnostics() {\n\t\tif (this.browser) {\n\t\t\tif (this.env) return this.env.languageService.getSyntacticDiagnostics('index.js')\n\t\t\telse return []\n\t\t}\n\n\t\ttry {\n\t\t\tconst res = await fetch(\"/tsserver/syntactic_diagnostics\")\n\t\t\tlet ret = await res.json()\n\t\t\treturn ret.content\n\n\t\t} catch (err) {\n\t\t\treturn []\n\t\t}\n\t}\n\n\n}\n\nclass Positioner {\n\tconstructor(x, y, w, h, unit = \"v\", position = \"fixed\") {\n\t\tthis.x = sig(x || 0);\n\t\tthis.y = sig(y || 0);\n\t\tthis.w = sig(w || 0);\n\t\tthis.h = sig(h || 0);\n\n\t\tthis.unit = unit;\n\t\tthis.position = position;\n\n\t\tthis.style = mem(() => {\n\t\t\tconst v = this.unit == \"v\" ? \"vh\" : this.unit;\n\t\t\tconst h = this.unit == \"v\" ? \"vw\" : this.unit;\n\n\t\t\treturn `\n\t\t\t\tposition: ${this.position};\n\t\t\t\ttop: ${this.y() + v};\n\t\t\t\tleft: ${this.x() + h};\n\t\t\t\theight: ${this.h() + v};\n\t\t\t\twidth: ${this.w() + h};\n\t\t\t`;\n\t\t});\n\t}\n\n\tget css() {\n\t\treturn this.style;\n\t}\n}\n\n// Pass Editor into M -> so the live code in editor can change stuff in this editor.\nclass Editor {\n  /**\n   * @param {Object} EditorOpts \n   * @param {State} EditorOpts.state \n   * */\n  constructor({ state, components, renderer }) {\n      if (!renderer) throw Error(\"Need a renderer\");\n      this.tsserver = new Tsserver()\n      if (state) state.tsserver = this.tsserver\n      /** @type {State}*/\n      this.state = state ? state : new State({ type: \"RootGroup\", tsserver: this.tsserver });\n    \n      this.iframe_pos = new Positioner(0, 0, 100, 100);\n      this.renderer = renderer;\n      this.renderers = components ? components : new RendererList();\n      this.positioner = new Positioner(0, 0, 100, 100);\n    \n      this.toggled = sig(false)\n      eff_on(this.toggled, () => {\n        if (this.toggled()){\n           this.positioner.x.set(85) \n        }else {\n          this.positioner.x.set(0)\n        }\n        \n      })\n    \n      this.root_element = undefined\n    \n      this.live_output = sig(null)\n      this.output = mem(() => this.state.model.blocks.map((b) => b.output || \"\").join(\"\") || \"\")\n\n      eff_on(this.output, () => { this.tsserver.update_file(this.output()) })\n\n      eff_on(this.live_output, () => {\n          if (this.live_output() && this.live_output() != null) {\n              let out = this.live_output()\n              this.tsserver.update_file(out)\n          }\n      })\n  }\n\n  register(type, fn_str) {\n      this.renderers.register(type, fn_str);\n  }\n\n  toggle_hide () {\n    this.toggled.set(!this.toggled())\n  }\n\n  get css() {\n      return this.positioner.css\n  }\n\n  write(){\n    if (this.root_element && \"function\" == typeof this.root_element?.write){\n      \n    }\n  }\n\n  bind(element, setter) {\n      const render = this.renderer;\n      const component = render(element, this.state);\n\n      setter((el) => {\n          Object\n              .entries(component)\n              .forEach(([key, value]) =>{\n                if (key == \"write\"){\n                  state.register_write(value)\n                }\n                \n                el[key] = value\n              });\n      });\n    \n      this.root_element = component\n      return component.render;\n  }\n  \n  // TODO: Broadcast a message, \n  // message can be an object, fn whatever\n  // might adopt a facet type architecture.\n  // editor_theme_facet = Facet.define()\n  // editor_theme_facet.of({value})\n  \n  // broadcast(editor_theme_facet.message({value}))\n  broadcast(message){\n    // inside:\n    // for each of blocks -> block.message(message)\n  }\n\n  show(element){\n    let found = this.state.blocks.find((el) => el.id == element.id)\n    if(found &&\n       found.top &&\n       found.left &&\n       found.width &&\n       found.height\n      ) {\n        let x = found.left()\n        let y = found.top()\n        let w = found.width()\n        let h = found.height()\n        this.root_element.show(x, y, w, h)\n      }\n  }\n  \n  render() {\n      const setter = (fn) => this.state.update(produce(fn));\n      return this.bind(this.state, setter);\n  }\n}\n\n//TODO: make these available at user runtime\nfunction state_utils(state) {\n  const find_focused = () => state.blocks.find((e) => e.focus);\n  const find_active = () => state.blocks.find((e) => e.active);\n\n  function move_child (index, direction) {\n    let changed = false\n    state.update_blocks(\n      produce((el) => {\n        if (!el[index + direction] || !el[index]) return;\n        let temp = el[index];\n        el[index] = el[index + direction];\n        el[index + direction] = temp;\n        changed = true\n      }),\n    );\n\n    if (changed) state.cursor.set(state.cursor() + direction)\n  };\n\n  \n  function is_scrollable(el) {\n\treturn el.scrollHeight > el.clientHeight;\n  }\n \n  \n  function find_offset_to_parent(el, parent) {\n\treturn [el.offsetLeft - parent.offsetLeft, el.offsetTop - parent.offsetTop];\n  }\n\n  function get_scrollabe_parent(el) {\n  \tlet found_parent = false;\n  \tlet element = el;\n  \n  \tdo {\n  \t\telement = element.parentElement;\n  \n  \t\tif (!element) return;\n  \t\tif (is_scrollable(element)) found_parent = true;\n  \t} while (!found_parent && element);\n  \n  \treturn element;\n  }\n\n\n  const scroll_to_active = () => {\n    let active = find_active()\n    if (!active) return\n    let id = \"block-\"+active.id\n    \n    let el = document.getElementById(id);\n    let parent = get_scrollabe_parent(el);\n    if (parent) {\n        let [x, y] = find_offset_to_parent(el, parent);\n        parent.scrollTo({ top: y - 50 });\n    }\n  }\n\n\n  const set_current_active = () => {\n      if (!state.blocks[state.cursor()]) return;\n      state.update_blocks(state.cursor(), \"active\", true);\n      state.update_blocks((_, i) => i != state.cursor(), \"active\", false);\n  };\n\n  const set_current_focus = () => {\n      if (!state.blocks[state.cursor()]) return;\n      const current = state.blocks[state.cursor()];\n      state.update_blocks(state.cursor(), \"focus\", true);\n      if (current.onfocus) current.onfocus();\n  };\n\n  const unfocus_current = () => {\n      const current = find_focused(state);\n      if (!current) return;\n      if (current.handle_unfocus) current.handle_unfocus()\n      else {\n          state.update_blocks((e) => e.focus, \"focus\", false);\n          if (current.onunfocus) current.onunfocus();\n      }\n  };\n\n\treturn {\n      find_focused,\n      find_active,\n      scroll_to_active,\n      set_current_active,\n      set_current_focus,\n      unfocus_current,\n      move_child,\n\t};\n}\n\n// TODO: Find better way to do this\n// maybe editor holds panzoom\n\nlet panzoom_scale = () => 1\n\nconst child_style = (child) => {\n  const active_is = mem(() => child.active && !child.focus);\n  const shadow_is = mem(() => child.focus);\n\n  const active = mem(() => active_is() \n    ? `\n    padding: 1em;\n    box-shadow: 0 0 50px 15px rgba(0,0,0,.1);\n    `\n    : \"filter: grayscale(1);\");\n\n  const box_shadow = mem(() =>\n      shadow_is() ? `\n      padding: 1em;\n      box-shadow: 0 0 25px 5px rgba(127,0,255,.1);\n      filter:none;\n      z-index: 99;\n      opacity:1;\n      ` : \"\"\n  );\n  \n  const coordinates = mem(() =>  { \n    if (!child.top\n        || !child.left\n        || !child.height\n        || !child.width\n       ) return \"\"\n\n    let width = child.width()\n    let height = child.height()\n\n    if (shadow_is() && fit_active()){\n      \n      width = (window.innerWidth - 200) / panzoom_scale()\n      height = (window.innerHeight - 200) / panzoom_scale() \n    }\n    \n    return `\n      top: ${child.top()}px;\n      left: ${child.left()}px;\n      width: ${width}px;\n      height: ${height}px;\n  `})\n  \n  const additional = mem(() => `\n        background: #ffffff11; \n        border: 1px solid #22222244;\n        position: absolute;\n        padding: 3px;\n        padding-top: 25px;\n        ${coordinates()}\n  `)\n\n\n  return mem(() => [ additional(), active(), box_shadow()].join(\";\"));\n};\n\n//TODO: add at current cursor\nconst add_block = (opts, state) => {\n  if (state.cursor() < -1 || state.cursor() >= state.blocks.length) return\n  if (!opts.id) opts.id = uid()\n  \n  editor.state.write()\n  \n  state.update_blocks(produce((e) =>\n    e.splice(state.cursor() + 1, 0, opts)) );\n\n}\n\nlet url_ = window.location \nlet to_load = \"/test/fileviewer.json\"\nif (url_.toString().includes(\"about:srcdoc\")){\n  console.log(\"src doc location\", url_)\n}\n  \nelse {\n  console.log(\"chillin at the club\", url_)\n  let path = url_.search.substring(1)\n\n  // TODO: If path exists ask server\n  console.log(path)\n\n  if(path) to_load = path\n}\n\nconst state = new State({})\nstate.load(to_load)\n\n\nconst editor = new Editor({ renderer: View, state });\n\n/**\n * @typedef {Object} View\n *\n * @property {(el) => void} write\n * @property {() => any[] | any} render\n *\n * @property {() => void} [onkeydown]\n * @property {() => void} [onfocus]\n * @property {() => void} [onunfocus]\n */\n\nwindow.onload = () => {\n\twindow.addEventListener(\"keydown\", (e) => {\n\t\tif (editor.state.model.onkeydown) {\n\t\t\teditor.state.model.onkeydown(e);\n\t\t}\n\t});\n};\n\n// Document as known issues\nconst f = \"/\";\nconst iframe = mem(() =>\n\t`<script type=\"module\"> \n        const SOURCE_PATH = \"${CURRENT_PATH()}\"\n        ${editor.state.blocks.map((e) => e.output).join(\"\\n\")}\n    <${f}script>`\n);\n\n// TODO: Make it so this is polled\neff_on(iframe, () => defer(function() {\n\tif (m()) m().EDITOR = editor\n}, 500))\n\nlet traveling = sig(true)\nlet smooth = sig(true)\nlet connectors = sig(false)\nlet fit_active = sig(false)\nlet buffer = mut([-1, -1, -1, -1, -1])\n// ----------------------------\n\nlet create_toggle_button = (title, signal) => {\n  let style = mem(() => signal() ?  ` opacity: 1 `: ` opacity: .5 `) \n  return h(\"button\", {\n    style: style,\n    onclick: (e) => { signal.set(!signal()) }\n  }, title)\n}\n\nlet bar_style = mem(()=>`\n  position: absolute;\n  bottom: 1em;\n  \n  left:${editor.toggled() ? 90 : 1}em;\n  z-index: 999;\n`)\n\nlet travel = create_toggle_button(\"[autofocus]\", traveling) \nlet smoothie = create_toggle_button(\"[smooth]\", smooth) \nlet throughtn = create_toggle_button(\"[through]\", through) \nlet connectorenable = create_toggle_button(\"[lines]\", connectors)\nlet curtains = create_toggle_button(\"[curtain]\", curtain) \nlet fitactivator = create_toggle_button(\"[fit]\", fit_active) \n\nlet buff_btn = (index, list) => {\n  let text = mem(() => list[index] == -1 ? \"x\" : list[index])\n  return h(\"button\", {onclick: () => list[index] = editor.state.cursor()}, text)\n}\n\nlet buffers = mem(() => {\n  return buffer.map((b, i) => {\n    return buff_btn(i, buffer)\n  })\n  \n})\n\nconst Root = () => {\n\tconst iframe_style = editor.iframe_pos.css;\n\tconst editor_style = mem(() => `\n      background-size: 20px 20px;\n      ${editor.toggled() ? `overflow: hidden;`: \"\" }\n      ${through() ? `pointer-events: none;`: \"\" }\n      ${curtain() ? \n      `background-image:\n\t\tlinear-gradient(to right, #0002 1px, transparent 1px),\n\t\tlinear-gradient(to bottom, #0002 1px, transparent 1px);\n       background-color: #fff9;\n        `\n        : \"\"\n      }\n      ` + editor.css());\n\n\treturn h(\"div\", [\n        h(\"style\", global_style),\n\t\th(\"iframe.iframe\", { ref: iframe_ref.set, srcdoc: iframe, style: iframe_style }),\n        h(\"div.bar\", {style: bar_style}, travel, smoothie, curtains, throughtn, fitactivator, connectorenable,buffers),\n\t\th(\"div.editor\", { style: editor_style }, editor.render()),\n\t]);\n};\n\nlet global_style = mem(() => `\n  html {\n    font-size: 14.5px;\n  }\n  \n  ::-webkit-scrollbar {display: none;}\n  \n  @font-face {\n    font-family: 'DiatypeMono';\n    src: url('/fs/fonts/diatype_mono.ttf') format('truetype');\n    }\n  \n  * {\n    padding: 0;\n    margin: 0;\n    font-size: 16px;\n    -ms-overflow-style: none;  /* IE and Edge */\n    scrollbar-width: none;  /* Firefox */\n    font-family: \"DiatypeMono\";\n  }\n\n  .child {\n    overflow-y: scroll;\n  }\n\n  input[type=\"text\"] {\n    all: unset;\n    border: 1px ${FOREGROUND} solid;\n    background: ${BACKGROUND};\n  }\n  \n  button {\n    all: unset;\n    cursor: pointer;\n    padding: 2px;\n    font-size: .8em;\n    color: ${FOREGROUND};\n    background: ${BACKGROUND};\n    border: 1px ${FOREGROUND} solid;\n    margin: 0 .5em ;\n  }\n  \n  iframe {\n    all: unset;\n  }\n  \n  body {\n    background:${BACKGROUND};\n    color: ${FOREGROUND};\n  }\n  \n  .group {\n    position: absolute;\n    top: 0;\n    left: 0;\n    background: ${GROUPBG()};\n    width: 500vw;\n    height: 500vh;\n  }\n\n  textarea {\n    all: unset;\n    background: ${BACKGROUND};\n    color: ${FOREGROUND};\n  }\n  \n  .md {\n    padding: 1em;\n    background-color: ${BACKGROUND};\n    color: ${FOREGROUND};\n  }\n`)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "active": false,
      "focus": false,
      "start": 0,
      "focused": false,
      "cursor": 0,
      "drag_x": 790.9809171762817,
      "drag_y": 1001.2767176209046,
      "drag_w": 680,
      "drag_h": 920
    },
    {
      "type": "group",
      "id": "d2hz5j",
      "active": false,
      "start": 25873,
      "drag_x": 1241.7137834723208,
      "drag_y": 2004.1361933927421,
      "drag_w": 600,
      "drag_h": 1200,
      "output": "",
      "blocks": [],
      "focus": false
    },
    {
      "type": "code",
      "id": "tmsrnv",
      "start": 25873,
      "drag_x": 1522.14347959944,
      "drag_y": 1326.8465296366953,
      "focused": false,
      "output": "\n// ----------------------------\n// What other variables to have\n// Where should this be stored?\n// store it in editor? root state?\n// maybe root state and can be passed by the editor\n// ----------------------------\n// ----------------------------\n// if load from state,\n// at user level, can edit the state...\n// and that can be the config. \n// and this way can also have config file...\n// load for -> keymaps, menu items.\n// In that case have to have a basic dsl (vim cmds type)\n// For config. \n// ----------------------------\n  \n// =============\n// Root Renderer\n// =============\n/**\n * @param {State} state\n */\nfunction View(el, state) {\n  if (!state) throw Error(\"NEED STATE\")\n\n  const blocks = el.blocks || [];\n  const cursor = el.cursor || -1;\n\n  setTimeout(() => {\n    const _buffer = state?.model?.properties?.buffer \n      ? state.model.properties.buffer\n      : [-1, -1, -1, -1, -1]\n\n    _buffer.forEach((e, i) => buffer[i] = e)\n  }, 100)\n\n  state = state || new State({ blocks, cursor });\n  \n\n  // add these to state as prototype?\n  const {\n    set_current_focus,\n    set_current_active,\n    find_focused,\n    find_active,\n    unfocus_current,\n    scroll_to_active,\n    move_child\n  } = state_utils(state);\n\n  eff_on(state.cursor, () => {\n    set_current_active()\n    if (traveling()) {\n      if (find_active()) editor.show(find_active())\n    }\n    // scroll_to_active()\n  });\n// bring active in scroll\n\n\nconst bind = (child, index) => {\n  if (!child) return;\n  const item = editor.renderers.find(child.type);\n  if (!(typeof item == \"function\")) return;\n\n  const setter = (...args) => state.update_blocks(index(), ...args);\n  const controller = { set_self: setter, state: state };\n  const component = item(child, index, controller);\n\n  const cur_x = () => {\n    let active =  find_active()\n    if (active && active.left) return active.left()\n  }\n  const cur_y = () => {\n    let active =  find_active()\n    if (active && active.left) return active.top()\n  }\n  \n  // TODO: For default position, check last child...\n  let left = sig(child.drag_x ? child.drag_x : cur_x() + 300)\n  let top = sig(child.drag_y ? child.drag_y : cur_y())\n  let width = sig(child.drag_w ? child.drag_w : 600)\n  let height = sig(child.drag_h ? child.drag_h : 400)\n  \n  \n  let onref = (e) =>  \n    setTimeout(() => drag(e, {set_left: left.set, set_top: top.set}), 10)\n  \n\n  setter(produce((block) => {\n      block.left = left\n      block.top = top\n      block.width = width\n      block.height = height\n    \n      Object\n          .entries(component)\n          .forEach(([key, value]) =>{\n\n            // --------------------\n            // middleware for write\n            // --------------------\n            if (key == \"write\") {\n              block[key] = (el) => {\n                el.drag_x = left()\n                el.drag_y = top()\n                el.drag_w = width()\n                el.drag_h = height()\n                \n                value(el)\n              }\n            }\n            \n            else {\n              block[key] = value;\n            }\n          })\n  }));\n\n  const style = child_style(child);\n  const click = () => { \n    unfocus_current()\n    state.cursor.set(index())\n    set_current_focus()\n    \n    if (traveling()) {\n      editor.show(child)\n    }\n  }\n  \n  let stats = () => h(\n    \"span.stats\",\n    () => `(${index()})`,\n    () => `x: ${parseInt(left())}, y: ${parseInt(top())}`\n  )\n  \n  // on active show x and y\n  return h(\n    \"div.child\",\n    \n    { \n      ref: onref,\n      style: style,\n      onclick: click,\n     id: \"block-\" + child.id\n    },\n    \n    stats, component.render);\n};\n\n  // TODO: Clean this up.. maybe make generic fn?\n  // UpdateCoordinates(x: (add | set), y, w, h)\n\n  let unit = () => 10 / panzoom_scale()\n  // increase cur left\n  // increase cur top\n  const inc_cur_left = () => {\n    let current = find_active()\n    if (!current) return\n    current.left?current.left.set(current.left() + unit()):null\n  }\n  \n  const dec_cur_left = () => {\n    let current = find_active()\n    if (!current) return\n    current.left?current.left.set(current.left() - unit()):null\n  }\n  \n  const inc_cur_top = () => {\n    let current = find_active()\n    if (!current) return\n    current.top?current.top.set(current.top() + unit()):null\n  }\n  \n  const dec_cur_top = () => {\n    let current = find_active()\n    if (!current) return\n    current.top?current.top.set(current.top() - unit()):null\n  }\n  \n  const dec_cur_width = () => {\n    let current = find_active()\n    if (!current) return\n    current.width?current.width.set(current.width() - unit()):null\n  }\n  \n  const inc_cur_width = () => {\n    let current = find_active()\n    if (!current) return\n    current.width?current.width.set(current.width() + unit()):null\n  }\n  \n  const dec_cur_height = () => {\n    let current = find_active()\n    if (!current) return\n    current.height?current.height.set(current.height() - unit()):null\n  }\n  \n  const inc_cur_height = () => {\n    let current = find_active()\n    if (!current) return\n    current.height?current.height.set(current.height() + unit()):null\n  }\n  \n  const keys = new Keymanager();\n  \n  \n  // -----------------\n  // BASIC\n  // -----------------\n  keys.on(\"Escape\", unfocus_current);\n  keys.on(\"Enter\", set_current_focus);\n  \n  // -----------------\n  // Add Widgets\n  // -----------------\n  keys.on(\"shift+c\", (_) => add_block({ type: \"code\" }, state));\n  keys.on(\"shift+s\", (_) => add_block({ type: \"save-component\" }, state));\n  keys.on(\"shift+p\", (_) => add_block({ type: \"sandbox\" }, state));\n  keys.on(\"shift+v\", (_) => add_block({ type: \"video-component\" }, state));\n  keys.on(\"shift+m\", (_) => add_block({ type: \"md\" }, state));\n  keys.on(\"cmd+shift+l\", (_) => add_block({ type: \"load-component\" }, state));\n  keys.on(\"shift+g\", (_) => add_block({ type: \"group\" }, state));\n  \n  // -----------------\n  // navigate\n  // -----------------\n  keys.on(\"j\", (_) => state.next());\n  keys.on(\"k\", (_) => state.prev());\n\n  // -----------------\n  // buffers\n  // -----------------\n  const buff_press = (index) => \n    (buffer[index - 1] != -1  && buffer[index - 1] != undefined)\n    ? editor.state.cursor.set(buffer[index - 1])\n    : buffer[index - 1] = editor.state.cursor()\n  \n  \n  keys.on(\"1\", (_) => buff_press(1));\n  keys.on(\"2\", (_) => buff_press(2));\n  keys.on(\"3\", (_) => buff_press(3));\n  keys.on(\"4\", (_) => buff_press(4));\n  keys.on(\"5\", (_) => buff_press(5));\n\n  \n  // -----------------\n  // dimensions\n  // -----------------\n  keys.on(\"shift+h\", (_) => dec_cur_left())\n  keys.on(\"shift+j\", (_) => inc_cur_top())\n  keys.on(\"shift+k\", (_) => dec_cur_top())\n  keys.on(\"shift+l\", (_) => inc_cur_left())\n  keys.on(\"shift+ArrowRight\", (_) => inc_cur_width())\n  keys.on(\"shift+ArrowLeft\", (_) => dec_cur_width())\n  keys.on(\"shift+ArrowDown\", (_) => inc_cur_height())\n  keys.on(\"shift+ArrowUp\", (_) => dec_cur_height())\n  \n  // -----------------\n  // move children\n  // -----------------\n  keys.on(\"alt+shift+ArrowUp\", (_) => move_child(state.cursor(), -1))\n  keys.on(\"alt+shift+ArrowDown\", (_) => move_child(state.cursor(), 1))\n  \n  // -----------------\n  // hide editor\n  // -----------------\n  keys.on(\"cmd+e\", () => editor.toggle_hide())\n  keys.on(\"alt+t\", (_) => through.set(!through()))\n  keys.on(\"alt+c\", (_) => curtain.set(!curtain()))\n  keys.on(\"alt+a\", (_) => traveling.set(!traveling()))\n  keys.on(\"alt+s\", (_) => smooth.set(!smooth()))\n  keys.on(\"alt+f\", (_) => fit_active.set(!fit_active()))\n  \n  \n  // -----------------\n  // save\n  // -----------------\n  keys.on(\"ctrl+s\", (_) => state.write());\n  keys.on(\"cmd+s\", (_) => state.write());\n\n  let panzoom\n  let parent_ref = (e) => {\n    setTimeout(() => {\n      // check if initialX, y, zoom are there\n      let t = {...state.model.properties.panzoom}\n      console.log(\"t\", t)\n      panzoom = createPanZoom(e, {\n        beforeWheel: function(e) {\n          // allow wheel-zoom only if altKey is down. Otherwise - ignore\n          const shouldIgnore = !e.altKey;\n          return shouldIgnore;\n        }\n      }) \n      \n      \n      panzoom_scale = () => {\n        let scale = panzoom?.getTransform().scale\n        return scale\n      }\n      \n    }, 100)\n  }\n\n  const handle_keys = (e) => {\n      const focused = find_focused();\n\n      if (focused && e.key != \"Escape\") {\n          if (focused.onkeydown) focused.onkeydown(e);\n          return;\n      }\n      keys.event(e);\n  };\n\n  const write = (el) => {\n    let transform = panzoom.getTransform()\n    let pan = {\n      initialX: transform?.x,\n      initialY: transform?.y,\n      initialZoom: transform?.scale\n    }\n\n    console.log(\"saving\",pan)\n    \n    el.panzoom = pan\n    el.buffer = [...buffer]\n    console.log(\"saving\", el)\n  };\n\n  const Render = () => {\n    let id = uid()\n    let style = `\n      position: absolute;\n      top: 0;\n      left: 0;\n      width:100%;\n      height:100%;\n    `\n\n    let rect = (x, y, w, h) => {\n      let relation = (rx, ry, rw, rh) => {\n        let vertical = {\n          direction: \"\",\n          value: 0\n        }\n        \n        let horizontal = {\n          direction: \"\",\n          value: 0\n        }\n        \n        if (ry > y) {\n          vertical.direction = \"bottom\"\n          vertical.value =  ry - y\n        }else {\n          vertical.direction = \"top\"\n          vertical.value =  y - ry\n        }\n        if (rx > x) {\n          horizontal.direction = \"right\"\n          horizontal.value  = rx - x\n        } else {\n          horizontal.direction = \"left\"\n          horizontal.value  = x - rx\n        }\n    \n    \n        return {vertical, horizontal, stress: vertical.value > horizontal.value ? \"vertical\" : \"horizontal\" }\n        // returns either top, right, bottom or left\n      }\n    \n      let relation_midpoint = (x, y, w, h) => {\n        let relational = relation(x, y, w, h)\n        let point = midpoint(relational[relational.stress].direction)\n        return point\n      }\n      \n      let midpoint = (side = \"right\") => {\n        if (side == \"top\"){\n          return { x: x + (w/2), y }\n        }\n        \n        if (side == \"right\"){\n          return { x: x+w, y: y + (h/2) }\n        }\n        \n        if (side == \"left\"){\n          return { x, y: y + (h/2) }\n        }\n        \n        if (side == \"bottom\"){\n          return { x: x + (w/2), y: y+h }\n        }\n      }\n      \n      let transform = () => [x, y, w, h]\n    \n      return { relation, transform, midpoint, relation_midpoint }\n    }\n\n    \n    mounted(() => {\n      let c = document.getElementById(\"canvas-\"+id)\n      c.width = c.clientWidth\n      c.height = c.clientHeight\n      \n      let ctx = c?.getContext(\"2d\");\n      ctx.globalAlpha = 0.5\n    \n      // Set line width\n\n      console.log(ctx)\n\n      let circle = (x, y, radius) => {\n        ctx.beginPath();\n        ctx.arc(x, y, radius, 0, 2 * Math.PI);\n        ctx.stroke();\n      }\n\n      eff_on(() => state.blocks.map((b) => [b.top(), b.left(),  b.width(),  b.height() ]),\n       throttle(() => { \n        if (!connectors()) return\n        ctx.clearRect(0, 0, c.width, c.height);\n        let last = null\n         \n        state.blocks.forEach(block => {\n          if (last) {\n            let from = rect(last.left(), last.top(), last.width(), last.height())\n            let to = rect(block.left(), block.top(), block.width(), block.height())\n\n            let p1 = from.relation_midpoint(...to.transform())\n            let p2 = to.relation_midpoint(...from.transform())\n             \n            let a = p1.x - p2.x;\n            let b = p1.y - p2.y;\n            let dist = Math.sqrt( a*a + b*b );\n            if (dist > 300) ctx.setLineDash([8/panzoom_scale(),8/panzoom_scale()])\n            ctx.lineWidth = 1 / panzoom_scale();\n            \n            // Roof\n            ctx.beginPath();\n            ctx.moveTo(p1.x, p1.y);\n            ctx.lineTo(p2.x, p2.y);\n            ctx.stroke();\n            \n            ctx.setLineDash([])\n\n            circle(p1.x, p1.y, 10)\n            circle(p2.x, p2.y, 10)\n          }\n\n          last = block\n        })\n      }, 30))\n    })\n    \n    let canvas = () => h(\"canvas\", {id: \"canvas-\"+id, style})\n    return [\n      h(\"div.group\", {ref: parent_ref}, canvas, () => each(() => state.blocks, bind))\n    ]\n  }\n  const PADDING = 50\n\n  return {\n      // HERE: Add panzoom\n      render: Render,\n      onkeydown: handle_keys,\n      write: (el) => write(el),\n      // TODO: Should take in a block id\n      // TODO: and resolve this in here, so if I have \n      // TODO: a scrollable editor, can resolve for it too \n      show: (x, y, w, h) => {\n        let rect = {\n          bottom: y+h + PADDING,\n          left: x - PADDING,\n          right: x+w + PADDING,\n          top: y - PADDING\n        }\n\n\n        // TODO: Make this tweakable\n        if (smooth()){\n          let scale = panzoom?.getTransform().scale\n          let _x = -1*(x - (PADDING / scale)) * scale\n          let _y = -1*(y - (PADDING / scale)) * scale\n          panzoom?.smoothMoveTo(_x, _y)\n        } \n\n        // Figure out how to make it smoothZoom\n        else {\n          panzoom?.showRectangle(rect)\n          panzoom?.moveBy(0.1, .1)\n        }\n        \n        \n      }\n  };\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "cursor": 0,
      "active": false,
      "drag_w": 950,
      "drag_h": 970,
      "focus": false
    },
    {
      "type": "code",
      "id": "p313n",
      "start": 39035,
      "focused": false,
      "output": "// ------------------------\n// SLIDER ELEMENT\n// ------------------------\nfunction slider(state){\n  let val = sig(state.value ? state.value : 0)\n  let output = mem(() => `M.slider = ${val()};`)\n  eff_on(val, () => {\n    if (m()) m().slider = val() \n  })\n  \n  const renderer = () => {\n    return  h(\"div\", \n      h(\"input\", {\n        type: \"range\",\n        oninput: (e) => val.set(e.target.value)  }\n     ), h(\"p\", \"Value: \", val)\n    )\n  }\n\n  const write = (el) => {\n    el.output = output()\n    el.value = val()\n  }\n  \n  return {\n    render: renderer,\n    write: write\n  }\n}\neditor.register(\"slider\", slider.toString())\n\n// -----------------------\n// Video ELEMENT\n// ------------------------\nfunction video_element(state) {\n  let src = sig(state.src ? state.src : \"\")\n  let save = () => editor.state.save(src())\n\n  let ref = (ref) => ref.playbackRate = 1.8\n  \n  const renderer = () => h(\"div\", [\n    h(\"input\", {type: \"text\",\n                id: \"input-\"+state.id,\n                value: src,\n                oninput: (e) => src.set(e.target.value)}),\n    h(\"button\",{onclick: save}, \"save\"),\n    h(\"video\", {src: src, style: \"width: 90%\", ref: ref ,controls: true, playback: 1.5})\n  ])\n\n  return {\n    render: renderer,\n    write: (el) => {\n      el.src = src();\n      el.output = \"\"\n    },\n    onfocus: () => document.getElementById(\"input-\"+state.id)?.focus(),\n    onunfocus: () => document.getElementById(\"input-\"+state.id)?.blur()\n  }\n}\n\neditor.register(\"video-component\", video_element.toString())\n\n// -----------------------\n// SAVE ELEMENT\n// ------------------------\nfunction save_editor(state) {\n  let path = sig(state.path ? state.path : \"\")\n  let save = () => editor.state.save(path())\n  let autosave = sig(state.autosave ? state.autosave : false)\n\n  let autosave_text = mem(() => \n    autosave() \n    ? \"autosave is (ON)\"\n    : \"AUTOSAVE is -> OFF <-\"\n    )\n\n  let toggle_autosave = () => autosave.set(!autosave())\n  \n  const renderer = () => h(\"div\", [\n    h(\"input\", {type: \"text\",\n                id: \"input-\"+state.id,\n                value: path,\n                oninput: (e) => path.set(e.target.value)}),\n    h(\"button\",{onclick: save}, \"OVERWRITE\"),\n    h(\"button\",{onclick: toggle_autosave}, autosave_text)\n  ])\n\n  return {\n    render: renderer,\n    write: (el) => {\n      el.path = path();\n      el.output = \"\"\n      el.autosave = autosave()\n      if (autosave()) save()\n    },\n    onfocus: () => document.getElementById(\"input-\"+state.id)?.focus(),\n    onunfocus: () => document.getElementById(\"input-\"+state.id)?.blur()\n  }\n}\neditor.register(\"save-component\", save_editor.toString())\n  \n// -----------------------\n// LOAD ELEMENT\n// ------------------------\nfunction load_editor(state) {\n  console.log(\"path: \", state.path)\n  let path = sig(state.path ? state.path : \"\")\n  let load = () => editor.state.load(path())\n  let onkeydown = (e) => e.key == \"Enter\" ? load() : null\n  \n  const renderer = () => h(\"div\", [\n    h(\"input\", {type: \"text\",\n                id: \"input-\"+state.id,\n                value: path,\n                onkeydown: onkeydown,\n                oninput: (e) => path.set(e.target.value)}),\n    \n    h(\"button\",{onclick: load}, \"load\")\n  ])\n\n  return {\n    render: renderer,\n    write: (el) => {el.path = path();el.output = \"\"},\n    onfocus: () => document.getElementById(\"input-\"+state.id)?.focus(),\n    onunfocus: () => document.getElementById(\"input-\"+state.id)?.blur()\n  }\n}\neditor.register(\"load-component\", load_editor.toString())\n  \n// -----------------------\n// Editor Sizer\n// ------------------------\nfunction editor_sizer(state) {\n  let size = sig(state.size ? state.size : \"100\")\n  // let set_size = eff_on(size,() => {\n  //   if (size() < 20) return\n  //   let e_w = parseInt(size())\n  //   editor.positioner.w.set(e_w)\n  //   editor.iframe_pos.x.set(e_w)\n  //   editor.iframe_pos.w.set(100-e_w)\n  // })\n  \n  const renderer = () => h(\"div\", [ h(\"h1\", \"NOT SUPPORTING THIS\") ])\n\n  return {\n    render: renderer,\n    write: (el) => {el.size = size();el.output = \"\"},\n    onfocus: () => document.getElementById(\"input-\"+state.id)?.focus(),\n    onunfocus: () => document.getElementById(\"input-\"+state.id)?.blur()\n  }\n}\neditor.register(\"editor_sizer\", editor_sizer.toString())\n\n// -----------------------\n// Markdown renderer\n// ------------------------\n\nfunction md_renderer(state) {\n  let md = sig(state.md ? state.md : \"100\")\n  let focused = mem(() => state.focus ? true : false)\n  let id = \"input-\"+state.id\n  let input = () => document.getElementById(id)\n  \n  let onfocus = () => input().focus()\n  \n  let edit = () => h(\"textarea\", {\n    oninput: (e) => md.set(e.target.value),\n    id: id,\n    value: md,\n    style: \n      `width: 100%;\n       height: 100%;`\n  })\n\n\n  let show = mem(() => focused() \n    ? edit()\n    : h(\"div\", {class: \"md\"} , MD(md()))\n    )\n  \n  const renderer = () => {\n    return show\n    \n  } \n\n  return {\n    render: renderer,\n    write: (el) => {\n      el.md = md();\n      el.output = \"\"\n    },\n    onfocus: onfocus,\n  }\n}\neditor.register(\"md\", md_renderer.toString())\n\n// ------------------------\n// Sandbox Renderer\n// ------------------------\nfunction sandbox_renderer(state, i, c) {\n  // Sandbox should -> \n  // Have a code editor\n  // code editor will output a fn, \n  // that returns (h) html\n  // Code should have access to m()\n  \n  function evaluate_expression(exp) {\n    // Try block to evaluate the expression and handle potential errors\n    let result\n    try {\n      result = eval_code(exp);\n    } \n    catch (error) {\n      if (error instanceof EvalError)  console.log('EvalError:', error.message);\n      else  console.log('Error:', error.message);\n    }\n\n    if (result) return result\n  }\n\n  const code = mem(() => state?.renderer \n    ? state?.renderer \n    : ` function() {\n      return h(\"div\", \"hello world ass\")\n    }\n  `)\n  \n  const run_code = sig(code())\n  const id = uid();\n  let save, focus, focus_on_pos;\n\n  const render_fn = () => {\n      let auto_focus = sig(false)\n      mounted(() => {\n          let extensions = [keymap.of([\n            {\n              key: \"Mod-Shift-l\",\n              run: (e) => { \n                run_code.set(e.state.doc.toString())\n              }\n            }\n          ])]\n        \n          const cm_editor = make_code_mirror(code(), id, extensions);\n          focus = () => {\n            if(auto_focus()) setTimeout(() => cm_editor.focus(), 100);\n          }\n          save = function(el) {\n              // TODO: add \"\\n\" only when not already added... \n              // TODO: Also mirro mechanism where else doc is accessed.\n              const text = cm_editor.state.doc.toString() \n              el.output = \"\"\n              el.focused = cm_editor.hasFocus;\n              el.renderer = text;\n              el.cursor = cm_editor.state.selection.ranges[0].from;\n              run_code.set(text)\n          };\n\n          defer(function() {\n              if (state.cursor && state.focused) {\n                  const selection = { anchor: state.cursor, head: state.cursor };\n                  cm_editor.focus();\n                  cm_editor.dispatch({ selection });\n              }\n          });\n\n          eff_on(run_code, () => { render_code(run_code) })\n      });\n\n      function render_code(code){\n        // TODO: Make it so maybe_renderer \n        // can access state, pass in state...\n        if (code()){\n          let elem = document.querySelector(\".output-\"+id)\n          elem.innerHTML = \"\"\n          let maybe_renderer = evaluate_expression(code())\n          if (typeof maybe_renderer == \"function\"){\n            render(maybe_renderer, elem)\n          }\n        }\n      }\n\n    let overflow = `overflow-y: scroll;height: 100%;`\n    \n    let toggle_button =  (text, signal) => \n        () => h( \"button\",  {onclick: () => signal.set(!signal())}, text )\n    \n    let t = mem(() => auto_focus() ? \"f: on\":\"f: off\")\n    \n      return  h(\"div\", \n        {style: `\n          display: grid;\n          grid-template-rows: 5% 45% 50%;\n          height: 95%;\n          overflow: hidden;\n        `},\n        h(\"options\", { class: \"options-\" + id }, toggle_button(t, auto_focus)),\n        h(\"div\", { class: \"output-\" + id, style: overflow }),\n        h(\"div\", { class: \"editor-\" + id , style: overflow})\n    )\n  };\n\n  // TODO: COMPONENT: template object representation\n  // should have icons for things and have intellisense...\n  return ({\n      render: render_fn,\n      onfocus: () => focus(),\n      write: (...args) => save(...args),\n  });\n}\n\neditor.register(\"sandbox\", sandbox_renderer.toString())\n\n// ------------------------\n// Custom Renderer\n// ------------------------\nfunction custom_renderer(state, i, c) {\n  if (state.renderer) return eval_code(state.renderer)(state, i, c)\n    \n  const code = mem(() => state?.renderer \n    ? state?.renderer \n    :  custom_renderer.toString())\n\n  const id = uid();\n  let save, focus, focus_on_pos;\n\n  Vim.defineEx(\"write\", \"w\", () => editor.state.write());\n\n  const render = () => {\n      mounted(() => {\n          let extensions = []\n          const cm_editor = make_code_mirror(code(), id, extensions);\n          focus = () => setTimeout(() => cm_editor.focus(), 100);\n          save = function(el) {\n            \n              // TODO: add \"\\n\" only when not already added... \n              // TODO: Also mirro mechanism where else doc is accessed.\n              const text = cm_editor.state.doc.toString() \n              el.output = \"\"\n              el.focused = cm_editor.hasFocus;\n              el.renderer = text;\n              el.cursor = cm_editor.state.selection.ranges[0].from;\n          };\n\n          defer(function() {\n              if (state.cursor && state.focused) {\n                  const selection = { anchor: state.cursor, head: state.cursor };\n                  cm_editor.focus();\n                  cm_editor.dispatch({ selection });\n              }\n          });\n      });\n      return h(\"div\", { class: \"editor-\" + id });\n  };\n\n  // TODO: COMPONENT: template object representation\n  // should have icons for things and have intellisense...\n  return ({\n      render: render,\n      onfocus: () => focus(),\n      write: (...args) => save(...args),\n  });\n}\n\neditor.register(\"custom\", custom_renderer.toString())\n\n// ------------------------\n// GROUP Renderer\n// ------------------------\n/**\n * @typedef {Object} Controller\n * @property {State} state\n *\n */\n\n/**\n * @param {Controller} c \n */\nfunction GroupRenderer(el, i, c,) {\n\t// new state\n\tlet state = new State({ blocks: el.blocks || [], parent: c.state, id: el.id })\n\n\t// add these to state as prototype?\n\tconst {\n\t\tset_current_focus,\n\t\tset_current_active,\n\t\tfind_focused,\n\t\tunfocus_current,\n\t} = state_utils(state);\n\n\teff_on(state.cursor, set_current_active);\n\n\tconst _unfocus = () => {\n\t\t// if none in focus unfocus self, else just forward to unfocus current\n\t\tlet focused = find_focused()\n\t\tif (!focused) c.set_self(\"focus\", false)\n\t\telse unfocus_current()\n\t}\n\n\n\tconst bind = (child, index) => {\n\t\tif (!child) return;\n\t\tconst item = editor.renderers.find(child.type);\n\t\tif (!(typeof item == \"function\")) return;\n\n\t\tconst setter = (...args) => state.update_blocks(index(), ...args);\n\t\tconst controller = { set_self: setter, state: state };\n\t\tconst component = item(child, index, controller);\n\n\t\tsetter(produce((block) => {\n\t\t\tObject\n\t\t\t\t.entries(component)\n\t\t\t\t.forEach(([key, value]) => block[key] = value);\n\t\t}));\n\n\t\tconst style = child_style(child);\n\t\treturn h(\"div\", { style: style }, component.render);\n\t};\n\n\tconst keys = new Keymanager();\n\n\tkeys.on(\"Enter\" , set_current_focus);\n  \n\tkeys.on(\"j\", (_) => state.next());\n\tkeys.on(\"k\", (_) => state.prev());\n  \n\tkeys.on(\"shift+c\", (_) => add_block({ type: \"code\" }, state));\n\tkeys.on(\"shift+g\", (_) => add_block({ type: \"group\" }, state));\n\tkeys.on(\"ctrl+s\", (_) => state.write());\n\n\tconst handle_keys = (e) => {\n\t\tconst focused = find_focused();\n\n\t\tif (focused && e.key != \"Escape\") {\n\t\t\tif (focused.onkeydown) focused.onkeydown(e);\n\t\t\treturn;\n\t\t}\n\n\t\tkeys.event(e);\n\t};\n\n\tconst write = (el) => {\n\t\tstate.write();\n\t\tlet output = state.blocks.map((child) => child.output).join(\"\");\n\t\t//TODO : FUCKING FIX THIS\n\t\tstate.start = el.start\n\t\tel.output = output;\n\t\tel.blocks = state.blocks;\n\t};\n\n    const focus_on_position = (pos) => {\n      state.focus_on_pos(pos)\n    }\n\n\n\treturn {\n      render: () => h(\n        \"div.group\",\n        () => each(() => state.blocks, bind)\n      ),\n      onkeydown: handle_keys,\n      write: (el) => write(el),\n      handle_unfocus: _unfocus,\n      focus_on_pos: focus_on_position\n\t};\n}\n\neditor.register(\"group\", GroupRenderer.toString())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "cursor": 1093,
      "active": true,
      "focus": true,
      "drag_x": 1688.0243387238077,
      "drag_y": 2438.4160908383737,
      "drag_w": 750,
      "drag_h": 980
    },
    {
      "type": "code",
      "id": "t0gxe9",
      "start": 51699,
      "focused": false,
      "output": "\n// ------------------------\n// CODEMIRROR ELEMENT\n// ------------------------\nfunction code_element(state, index, control) {\n\tconst code = mem(() => state?.output ? state?.output : \"\");\n\n\t// only used for syncing with tsserver\n\tconst live_code = sig(\"\")\n\tconst id = uid();\n\tlet save, focus, focus_on_pos;\n\n\tVim.defineEx(\"write\", \"w\", () => editor.state.write());\n  \n\tVim.defineEx(\"cm\", \"cm\", (cm) => {\n      console.log(cm.cm6)\n      let s=cm.cm6.state.wordAt(3)\n      let r=cm.cm6.state.sliceDoc( s.from,  s.to)\n      console.log(s)\n      console.log(r)\n    });\n\n    // VIM Folding\n    Vim.defineAction(\"toggleFold\", (cm) =>  toggleFold(cm.cm6) )\n    Vim.defineAction(\"foldAll\", (cm) =>  foldAll(cm.cm6) )\n\n    Vim.mapCommand(\"zc\", \"action\", \"toggleFold\", {}, { context: \"normal\" });\n    Vim.mapCommand(\"zo\", \"action\", \"toggleFold\", {}, { context: \"normal\" });\n    Vim.mapCommand(\"zM\", \"action\", \"foldAll\", {}, { context: \"normal\" });\n\n\tconst live_output = mem(() => {\n      if (state.focus) {\n        let code_map = {}\n        code_map[state.id] = live_code()\n\n        // TODO: CLean this up\n        const get_state_code_and_map = (state, map) => {\n            let id = state.id\n            let code = state.blocks\n              .map((block) => map[block.id]\n                ? map[block.id]\n                : block.output\n                  ? block.output\n                  : \"\")\n              .join(\"\")\n\n            map[id] = code\n            return code\n        }\n\n        let parent = control.state\n        let full_code = \"\"\n\n        // check if control.state\n        while (parent) {\n            // console.log('checknig', parent)\n            full_code = get_state_code_and_map(parent, code_map)\n            parent = parent.parent\n        }\n\n        return full_code\n      }\n\t\telse return null\n\t})\n\n\teff_on(live_output, () => {\n\t\tif (live_output()) editor.live_output.set(live_output())\n\t\telse editor.live_output.set(null)\n\t})\n\n\t// codemirro on change extension\n\n\tconst render = () => {\n    mounted(() => {\n      const cursorTooltipBaseTheme = EditorView.baseTheme({\n      \".cm-tooltip.cm-tooltip-cursor\": {\n        backgroundColor: \"#66b\",\n        color: \"white\",\n        border: \"none\",\n        padding: \"2px 7px\",\n        borderRadius: \"4px\",\n        \"& .cm-tooltip-arrow:before\": {\n          borderTopColor: \"#66b\"\n        },\n        \"& .cm-tooltip-arrow:after\": {\n          borderTopColor: \"transparent\"\n        }\n      }\n      }) \n\n\n      let def = sig(\"\")\n      let dom_ref = undefined\n      let hover = sig(true)\n      let definition_pos = sig(null)\n        \n      function get_cursor_tooltips (_state)  {\n        // TODO: Rewrite to throttle and also not map all selections\n        // TODO: and only first one...\n         return _state.selection.ranges\n          .map(range => {\n            \n            let line = _state.doc.lineAt(range.head)\n            \n            // *****************************\n            // TODO: Throttle this, runs too many times \n            // *****************************\n            if(hover()){\n              let start = state.start ? state.start : 0\n              let p = start+range.head\n              \n              control.state.quick_info(p).then((res) => {\n                if (res) dom_ref.textContent = res\n              })\n            }\n            \n            return {\n              pos: range.head,\n              above: true,\n              strictSide: true,\n              arrow: true,\n              create: () => {\n                let dom = document.createElement(\"div\")\n                dom.className = \"cm-tooltip-cursor\"\n                dom.textContent = def()\n                dom.style.display = hover() ? \"\" : \"none\"\n                dom_ref = dom\n                return { dom }\n              }\n            }\n          })[0]\n        \n      }\n      const cursorTooltipField = StateField.define({\n        create: get_cursor_tooltips,\n      \n        update: function(tooltips, tr) {\n          if (!tr.docChanged && !tr.selection && !hover()) return tooltips\n          return get_cursor_tooltips(tr.state)\n        },\n        \n        provide: f => hover() ? showTooltip.compute([f], state => state.field(f)) : null\n      })\n      function tooltip () {\n        return  [cursorTooltipField, cursorTooltipBaseTheme]\n      }\n  \n      let extensions = [\n        tooltip(),\n        linter(() => {\n            let start = state.start ? state.start : 0\n            let end = start + live_code().length\n            return control.state.lint(start, end)\n        }),\n      \n        keymap.of([\n            {\n              key: \"Mod-Shift-i\",\n              run: () =>  {\n                hover.set(!hover())\n                if (dom_ref) dom_ref.style.display = hover() ? \"\" : \"none\"\n              }\n            },\n            {\n              key: \"Mod-Shift-u\",\n              run: (e) =>  {\n                // get references from editor for cur position, then tell \n                // editor to focus there\n                let start = state.start ? state.start : 0\n                control\n                  .state\n                  .find_definition(e.state.selection.ranges[0].head + start)\n                  .then((pos) => {\n                    if (pos) editor.state.focus_on_pos(pos)\n                  })\n              }\n            },\n        ]),\n  \n        autocompletion({\n            activateOnTyping: true,\n            maxRenderedOptions: 20,\n            override: [async (ctx) => {\n                let { pos } = ctx\n                let start = state.start ? state.start : 0\n                let completion = await control.state.completion(pos + start, ctx)\n                return completion\n            }],\n        }),\n        \n  \n        EditorView.updateListener.of(throttle((e) => live_code.set(e.state.doc.toString() + \"\\n\"), 100))\n      ]\n  \n      const cm_editor = make_code_mirror(code(), id, extensions);\n      focus = () => setTimeout(() => cm_editor.focus(), 100);\n    \n      save = function(el) {\n          // TODO: add \"\\n\" only when not already added... \n          // TODO: Also mirro mechanism where else doc is accessed.\n          const text = cm_editor.state.doc.toString() + \"\\n\"\n          el.focused = cm_editor.hasFocus;\n          el.output = text;\n          el.cursor = cm_editor.state.selection.ranges[0].from;\n      };\n  \n      focus_on_pos = (pos) => {\n        let start = state.start ? state.start : 0\n        \n        cm_editor.dispatch({\n          selection:  {anchor: pos - start , head: pos - start }, \n          scrollIntoView: true \n        })\n        \n        focus()\n      }\n      \n      defer(function() {\n        hover.set(false)\n        if (state.cursor && state.focused) {\n          const selection = { anchor: state.cursor, head: state.cursor };\n          cm_editor.focus();\n          cm_editor.dispatch({ selection });\n        }\n    });\n  });\n  return h(\"div\", { class: \"editor-\" + id });\n};\n\n\t// TODO: COMPONENT: template object representation\n\t// should have icons for things and have intellisense...\n\treturn ({\n      render: render,\n      onfocus: () => focus(),\n      write: (...args) => save(...args),\n      focus_on_pos: (pos) => focus_on_pos(pos)\n\t});\n}\neditor.register(\"code\", code_element.toString());\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "cursor": 0,
      "active": false,
      "focus": false,
      "drag_x": 3727.269861597189,
      "drag_y": 977.2980238272248,
      "drag_w": 830,
      "drag_h": 960
    },
    {
      "type": "code",
      "id": "u1e5bg",
      "active": false,
      "focus": false,
      "start": 58979,
      "drag_x": 5168.3988140395095,
      "drag_y": 1570.8923989200384,
      "drag_w": 780,
      "drag_h": 970,
      "focused": false,
      "output": "\n// ------------------------\n// CODEMIRROR UTILS\n// ------------------------\nfunction make_code_mirror(source, id, extensions, language = javascript) {\n\tconst element = document.querySelector(\".editor-\" + id);\n\tconst state = {\n\t\tdoc: source,\n\t\textensions: [\n\t\t\tvim(),\n\t\t\tlanguage(),\n          \n\t\t\tbasicSetup,\n\t\t\ttheme,\n          \n\t\t\tkeymap.of([\n                indentWithTab,\n                {\n                  key: \"Mod-e\",\n                  run: () => toggleFold(editor)\n                },\n                {\n                  key: \"Mod-shift-e\",\n                  run: () => foldAll(editor)\n                },\n\t\t\t\t{\n\t\t\t\t\tkey: \"Escape\",\n\t\t\t\t\trun: () => {\n\t\t\t\t\t\teditor.contentDOM.blur();\n\t\t\t\t\t\twindow.getSelection()?.removeAllRanges();\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]),\n\t\t\t...extensions,\n\t\t],\n\t};\n\n\tconst editor = new EditorView({\n\t\tparent: element,\n\t\tstate: EditorState.create(state),\n\t});\n\n\treturn editor;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "cursor": 0
    },
    {
      "type": "code",
      "id": "geuvga",
      "start": 59953,
      "focused": false,
      "output": "\nconst createTheme = ({ variant, settings, styles }) => {\n\tconst theme = EditorView.theme(\n\t\t{\n\t\t\t// eslint-disable-next-line @typescript-eslint/naming-convention\n\t\t\t\"&\": {\n\t\t\t\tbackgroundColor: settings.background,\n\t\t\t\tcolor: settings.foreground,\n\t\t\t},\n\t\t\t\".cm-editor.cm-focused\": {\n\t\t\t\toutline: \"none\",\n\t\t\t},\n\t\t\t\".cm-content\": {\n\t\t\t\tcaretColor: settings.caret,\n\t\t\t},\n\t\t\t\".cm-cursor, .cm-dropCursor\": {\n\t\t\t\tborderLeft: \"2px solid\" + settings.caret,\n\t\t\t},\n\t\t\t\"&.cm-focused .cm-selectionBackgroundm .cm-selectionBackground, .cm-content ::selection\":\n\t\t\t{\n\t\t\t\tbackgroundColor: settings.selection,\n\t\t\t},\n\t\t\t\".cm-activeLine\": {\n\t\t\t\tbackgroundColor: settings.lineHighlight,\n\t\t\t},\n\t\t\t\".cm-gutters\": {\n\t\t\t\tbackgroundColor: settings.gutterBackground,\n\t\t\t\tcolor: settings.gutterForeground,\n\t\t\t},\n            \"&.cm-focused .cm-fat-cursor\": {\n              background: settings.caret,\n              \n            },\n\t\t\t\".cm-activeLineGutter\": {\n\t\t\t\tbackgroundColor: settings.lineHighlight,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdark: variant === \"dark\",\n\t\t},\n\t);\n\n\tconst highlightStyle = HighlightStyle.define(styles);\n\tconst extension = [theme, syntaxHighlighting(highlightStyle)];\n\n\treturn extension;\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "cursor": 0,
      "active": false,
      "focus": false,
      "drag_x": 4592.647755940285,
      "drag_y": 3286.8096990547588,
      "drag_w": 570,
      "drag_h": 690
    },
    {
      "type": "code",
      "id": "pd2kq",
      "active": false,
      "focus": false,
      "start": 61190,
      "drag_x": 2907.839793578909,
      "drag_y": 3127.3563542535917,
      "drag_w": 600,
      "drag_h": 920,
      "focused": false,
      "output": "const theme = createTheme({\n\tvariant: \"dark\",\n\tsettings: {\n\t\tbackground: BACKGROUND,\n\t\tforeground: FOREGROUND,\n\t\tcaret: \"yellow\",\n\t\tselection: \"#ffffff26\",\n\t\tgutterBackground: \"#fcfcfc22\",\n\t\tgutterForeground: \"#8a919922\",\n\t\tlineHighlight: \"#8a919922\",\n\t},\n\tstyles: [\n\t\t{\n\t\t\ttag: t.comment,\n\t\t\tcolor: \"#00000066\",\n\t\t},\n\t\t{\n\t\t\ttag: t.string,\n\t\t\tcolor: \"#7EB282\",\n\t\t},\n\t\t{\n\t\t\ttag: t.regexp,\n\t\t\tcolor: \"#4cbf99\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.number, t.bool, t.null],\n\t\t\tcolor: \"yellow\",\n            \"background-color\": \"#0002\"\n\t\t},\n\t\t{\n\t\t\ttag: t.variableName,\n\t\t\tcolor: \"#7E74BC\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.definitionKeyword, t.modifier],\n\t\t\tcolor: \"#FF7B72\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.keyword, t.special(t.brace)],\n\t\t\tcolor: \"#FF7B72\",\n\t\t},\n\t\t{\n\t\t\ttag: t.operator,\n\t\t\tcolor: \"grey\",\n\t\t},\n      \n\t\t{\n          tag: t.separator,\n          color: \"grey\",\n\t\t},\n\t\t{\n          tag: t.punctuation,\n          color: \"grey\"\n\t\t},\n\t\t{\n          tag: [t.definition(t.propertyName), t.function(t.variableName)],\n          color: \"#7E74BC\",\n          \"font-family\": \"hermit\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.className, t.definition(t.typeName)],\n\t\t\tcolor: \"orange\",\n\t\t},\n\t\t{\n\t\t\ttag: [t.tagName, t.typeName, t.self, t.labelName],\n\t\t\tcolor: \"grey\",\n\t\t},\n\t\t{\n\t\t\ttag: t.angleBracket,\n\t\t\tcolor: \"violet\",\n\t\t},\n\t\t{\n\t\t\ttag: t.attributeName,\n\t\t\tcolor: \"#F66BAC\",\n\t\t},\n\t],\n});\n\nrender(Root, document.body);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "cursor": 0
    },
    {
      "type": "load-component",
      "id": "40oxq5",
      "start": 62673,
      "path": "L",
      "output": "",
      "active": false,
      "focus": false,
      "drag_x": 778.786259032764,
      "drag_y": 3564.3909433809067,
      "drag_w": 260,
      "drag_h": 50
    },
    {
      "type": "save-component",
      "id": "zri8um",
      "start": 62673,
      "path": "editor/canvas-editor.json",
      "output": "",
      "active": false,
      "focus": false,
      "drag_x": 215.72955292623118,
      "drag_y": 1609.2145545141698,
      "drag_w": 230,
      "drag_h": 70,
      "autosave": true
    },
    {
      "type": "editor_sizer",
      "id": "mkyf1t",
      "start": 62673,
      "drag_x": 35.81761176844228,
      "drag_y": 695.6793885491453,
      "size": "100",
      "output": "",
      "active": false,
      "focus": false,
      "drag_w": 600,
      "drag_h": 80
    },
    {
      "type": "editor_sizer",
      "id": "t0njv5",
      "start": 62673,
      "size": "51",
      "output": "",
      "active": false,
      "focus": false,
      "drag_x": 16.006270547135678,
      "drag_y": 536.6791173668344,
      "drag_w": 600,
      "drag_h": 80
    },
    {
      "type": "load-component",
      "id": "j5nwde",
      "start": 62673,
      "drag_x": 716.5163543236176,
      "drag_y": 531.5348947827131,
      "path": "",
      "output": "",
      "active": false,
      "focus": false,
      "drag_w": 250,
      "drag_h": 60
    },
    {
      "type": "group",
      "id": "myqjrf",
      "start": 62673,
      "drag_x": 43.69716716902735,
      "drag_y": 348.754399425238,
      "drag_w": 210,
      "drag_h": 30,
      "output": "console.log(\"this is a group\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconsole.log(\"I have to fix group styles, they are position absolute right now....\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "blocks": [
        {
          "type": "code",
          "id": "62dnd",
          "active": true,
          "focus": false,
          "start": 0,
          "focused": false,
          "output": "console.log(\"this is a group\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
          "cursor": 0
        },
        {
          "type": "code",
          "id": "97qzjs",
          "active": false,
          "focus": false,
          "start": 102,
          "focused": false,
          "output": "console.log(\"I have to fix group styles, they are position absolute right now....\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
          "cursor": 0
        }
      ],
      "active": false,
      "focus": false
    },
    {
      "type": "md",
      "id": "oyhype",
      "start": 62929,
      "drag_x": 2064.990052556507,
      "drag_y": 20.756620532395324,
      "drag_w": 590,
      "drag_h": 650,
      "md": "# Things to implement\n\n### Priorities\n- telescope\n\n### Next on\n- Mode switch from canvas to linear....\n- panzoom keyboard based navigation \n- Component live output\n- component templates\n- something like notion where you can do /select component\n\n# REGISTERS\n- quick make session...\n- have [button]\n- when button clicked, it will record cur cursor pos\n- set buffer[index] to the cursor pos\n- onkey -> index (1,2,3) -> set cursor to that",
      "output": "",
      "active": false,
      "focus": false
    },
    {
      "type": "md",
      "id": "cvxan",
      "active": false,
      "focus": false,
      "start": 62929,
      "drag_x": 2767.5678854244134,
      "drag_y": 41.786462862891774,
      "drag_w": 500,
      "drag_h": 810,
      "md": "# TELESCOPE\n- Do this!\n- Simple stuff, it will render this datatype:\n\n```js\n{\n  title: string,\n  onhover: () => void,\n  onenter: () => void,\n  preview: (hover: Signal<boolean>) => html\n}[]\n```\n\n- and it will just manage the hover enter and searching through this array, clicking and destroying.\n- For nested results, onenter can create a new list and that all!\n- onenter will exec the fn and hide itself\n- activate for telescope will require a list in that datatype.\n\n# A config file\n#### What all will this need?\n- a way to specify functions.\n- should config also be a js file? \n- or a json file...\n\n# Focusing\n- focusing state should be saved, autofocus and smooth\n- When autofocusing only then show option to smooth or not\n\n# What key\n- have what keys are available on the menu bar or whatever\n- component specific what key, (components if they return a keymanager for keydown, then use that to show key hints)\n\n# Rewrite Panzoom\n- Panzoom is funky and I don't know what happens inside it, rewrite it so I can see whats going on and implement things as I need them...\n\n# Sandbox Tsserver adapter\n- get tsserver working in sandbox\n- And this will help add support for multiple files later...",
      "output": ""
    },
    {
      "type": "md",
      "id": "g35h3m",
      "active": false,
      "focus": false,
      "start": 62929,
      "drag_x": 3431,
      "drag_y": 61.69370882973385,
      "drag_w": 600,
      "drag_h": 660,
      "md": "# Done\n\n\n- ~~Autofocus on canvas~~\n- ~~Basic menu bar~~\n- ~~onclick make active~~\n- ~~autosave figure out how you can do this~~\n- ~~add-comp at cursor~~\n- ~~calculate comp position based on~~\n- ~~fix groups~~",
      "output": ""
    }
  ],
  "output": "",
  "properties": {
    "panzoom": {
      "initialX": -1577.2761256209847,
      "initialY": -2300.6816104545387,
      "initialZoom": 0.9639962732332609
    },
    "buffers": [
      2,
      3,
      -1,
      -1,
      -1
    ],
    "buffer": [
      -1,
      -1,
      -1,
      -1,
      -1
    ]
  }
}