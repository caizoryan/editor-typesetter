{
  "blocks": [
    {
      "type": "load-component",
      "id": "ctkln",
      "start": 0,
      "drag_x": 35.95947368653305,
      "drag_y": 94.0131578366737,
      "path": "",
      "output": "",
      "active": false,
      "focus": false,
      "drag_w": 250,
      "drag_h": 50
    },
    {
      "type": "save-component",
      "id": "zp9lli",
      "start": 0,
      "drag_x": 31.94382665983347,
      "drag_y": 191.95004593369575,
      "path": "test/omama-viewer.json",
      "output": "",
      "active": false,
      "focus": false,
      "drag_w": 410,
      "drag_h": 50,
      "autosave": true
    },
    {
      "type": "code",
      "output": "import {mem,mut, eff_on} from \"/lib/solid/monke.js\"\nimport { THREE, addons } from \"/lib/threejs/three.js\"\nimport {Keymanager} from \"/lib/keymanager.js\"\n\nconst M = mut({\n  fn: {},\n  eff_on: [],\n  off: {\n    x: 0,\n    y: -10,\n    z: -.1,\n  }\n})\n\ndocument.M = M\n\n// basic styling\nlet style = document.createElement(\"style\")\nstyle.innerText= `*{padding: 0;margin:0}`\ndocument.head.appendChild(style)\n\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );\nconst orbit = addons.OrbitControls\nconst loader = new THREE.TextureLoader()\n\nlet structure = undefined\n\nconst renderer = new THREE.WebGLRenderer();\nrenderer.setSize( window.innerWidth, window.innerHeight );\ndocument.body.appendChild( renderer.domElement );\n\nfunction apply_offset(){\n  console.log(M.off)\n  if (structure){\n    Object.values(structure).forEach((cateogry, c_index) => {\n      if (!cateogry) return\n      cateogry.forEach((el, e_index) => {\n        if (!el || !el.position) return\n        \n        el.position.x = e_index * M.off.x\n        el.position.y = c_index * M.off.y\n        el.position.z = e_index * M.off.z\n      })\n    })\n  }\n}\n\neff_on(() => Object.values(M.off), apply_offset )\n// eff_on(() => M.off.z, apply_offset )\n// eff_on(() => M.off.y, apply_offset )\n\n\n// function register(dep, fn){ eff_on(dep, () => fn()) }\n// eff_on(() => M.eff_on, () => {\n//   if (Array.isArray(M.eff_on)\n//       && M.eff_on.length > 0\n//      ){\n    \n//     const key = M.eff_on[0] + \"\"\n//     const value = M.eff_on[1] + \"\"\n    \n//     register(mem(() => M[key]), M.fn[value])\n//   }\n// })\n\nlet c = new orbit(camera, renderer.domElement)\ncamera.position.z = 5;\nc.update()\n\nlet keys = new Keymanager()\nkeys.on(\"ArrowUp\", () => camera.position.z -= 2)\nkeys.on(\"ArrowDown\", () => camera.position.z += 2)\n\nwindow.addEventListener(\"keydown\",(e) => keys.event(e))\n\nfunction animate() {\n  requestAnimationFrame(animate)\n  \n  if (structure) {\n    Object.values(structure).forEach((cateogry) => {\n      if (!cateogry) return\n      // count++\n      // if (count > 100) return\n      cateogry.forEach(el => {\n        if (!el || !el.tick) return\n        if (typeof el.tick == \"function\") el.tick()\n      })\n      \n      // el.tick()\n    })\n  }\n  \n  renderer.render( scene, camera );\n  c.update()\n}\n\nanimate()\n\n\n\n\n\n\n",
      "start": 0,
      "drag_x": 1154.4967982744517,
      "drag_y": 461.70618422736453,
      "focused": false,
      "cursor": 0,
      "active": false,
      "focus": false,
      "drag_w": 600,
      "drag_h": 1200
    },
    {
      "type": "code",
      "id": "he3gnn",
      "start": 2339,
      "drag_x": 1990.1371397277696,
      "drag_y": 1470.9804086103186,
      "focused": false,
      "output": "\n/**\n@typedef {Object} vec3 \n@property {number} vec3.x\n@property {number} vec3.y\n@property {number} vec3.z\n\n@param {vec3} vec1\n@param {vec3} vec2\n*/\nfunction eq(vec1, vec2){\n  return vec1.x === vec2.x \n    && vec1.y == vec2.y\n    && vec1.z == vec2.z\n}\n\n\nfunction shuffle(arr) {\n  return arr.sort(() => Math.random() > .5 ? 1 : -1)\n  \n}\n\n\n\n\n\n\n",
      "cursor": 0,
      "active": false,
      "focus": false,
      "drag_w": 600,
      "drag_h": 1200
    },
    {
      "type": "code",
      "id": "wcbpv2",
      "start": 2681,
      "drag_x": 1994.8378741023682,
      "drag_y": 439.4254127578353,
      "focused": false,
      "output": "\nlet dir = \"/fs/media/omama_is_a_monkey/\"\n//let dir_2 = \"/fs/media/scrolls/gaming/\"\n\n// create promises for both, \n// and when get all requests, create structure\nlet p_1 = new Promise((resolve, reject) => {\n  fetch_category(dir).then((res) => resolve(res))\n});\n\n// let p_2 = new Promise((resolve, reject) => {\n//   fetch_category(dir_2).then((res) => resolve(res))\n// });\n\nPromise.all([p_1])\n  .then((res) => { \n    console.log(res)\n    structure=init_structure(res)\n  })\n\nasync function fetch_category(dir){\n  return await fetch(dir)\n    .then((res) => res.json())\n    .then((res) => {\n      return {\n        title: `gaming-${parseInt(Math.random() * 50)}`,\n        files: shuffle(res.files.map(file => dir+file))\n      }\n    })\n}\n\n\n\n\n\n\n\n",
      "cursor": 601,
      "active": false,
      "focus": false,
      "drag_w": 600,
      "drag_h": 910
    },
    {
      "type": "custom",
      "id": "r43x8q",
      "start": 3420,
      "drag_x": 3730.307110715135,
      "drag_y": 1831.4570684242424,
      "output": "",
      "focused": false,
      "renderer": "function custom_renderer(state, i, c) {\n  const code = mem(() => state?.renderer \n    ? state?.renderer \n    :  custom_renderer.toString())\n\n  const id = uid();\n  const output = sig(\"\")\n  let save, focus, focus_on_pos;\n\n  const output_component = () => {\n\n    let parent = `\n      position: relative;\n      width: 400px;\n      height: 400px;\n      background: white;\n    `\n\n    let one_coords = mut({ x: 0, y: 0 })\n    let two_coords = mut({ x: 0, y: 0 })\n    eff_on(() => one_coords.x, \n           () => {\n             if (m()){\n               m().off_x = one_coords.x / 200\n             }\n           })\n    \n    eff_on(() => one_coords.y,\n           () => {\n             if (m()){\n               m().off_z = (one_coords.y / 200) * -1 \n             } \n           })\n    \n    setTimeout(() => one_coords.x = -.2, 3000)\n\n    let wi = 50, he=50\n    \n    let one = mem(() => `\n      position: absolute;\n      top: ${one_coords.y}px;\n      left: ${one_coords.x}px;\n      width: ${wi}px;\n      height: ${he}px;\n      background: black;\n    `)\n\n    let one_ref = (e) => {\n      const set_left = (x) => one_coords.x = x\n      const set_top = (y) => one_coords.y = y\n      setTimeout(() => drag(e,  {set_left, set_top} ), 200) \n    }\n\n    // 1 parent\n    // 2 divs\n    // x distance between divs = x offset\n    \n    return h(\"div\", {style: parent}, \n             h(\"div\", {style: one, ref: one_ref}))\n  }\n\n  const render = () => {\n    mounted(() => {\n      const cm_editor = make_code_mirror(code(), id, []);\n      focus = () => setTimeout(() => cm_editor.focus(), 100);\n      \n      save = function(el) {\n        const text = cm_editor.state.doc.toString() \n        el.output = output()\n        el.focused = cm_editor.hasFocus;\n        el.renderer = text;\n        el.cursor = cm_editor.state.selection.ranges[0].from;\n      };\n\n      defer(function() {\n        if (state.cursor && state.focused) {\n          const selection = { anchor: state.cursor, head: state.cursor };\n          cm_editor.focus();\n          cm_editor.dispatch({ selection });\n        }\n      });\n    });\n    return  h(\"div\", \n              h(\"div\", output_component),\n              h(\"div\", { class: \"editor-\" + id }))\n  };\n\n  return ({\n      render: render,\n      onfocus: () => focus(),\n      write: (...args) => save(...args),\n  });\n}",
      "cursor": 0,
      "active": false,
      "focus": false,
      "drag_w": 600,
      "drag_h": 1200
    },
    {
      "type": "sandbox",
      "id": "d53gsj",
      "active": true,
      "focus": true,
      "start": 3420,
      "drag_x": 4388.468109408692,
      "drag_y": 957,
      "drag_w": 600,
      "drag_h": 830,
      "output": "",
      "focused": false,
      "renderer": "function() {\n\n  let one_coords = mut({ x: 0, y: 0 })\n  let two_coords = mut({ x: 0, y: 0 })\n  \n  eff_on(() => one_coords.x, \n         () => {\n           if (m()) m().off.x = one_coords.x / 200\n         })\n  \n  eff_on(() => one_coords.y,\n         () => {\n           if (m()) m().off.z = (one_coords.y / 200) * -1\n         })\n  \n  let wi = 50, he=50\n  \n  let one_ref = (e) => one_ref = e\n  mounted (() => {\n      const set_left = (x) => one_coords.x = x\n      const set_top = (y) => one_coords.y = y\n      setTimeout(() => drag(one_ref,  {set_left, set_top} ), 200) \n  })\n\n  \n  let one = mem(() => `\n    position: absolute;\n    top: ${one_coords.y}px;\n    left: ${one_coords.x}px;\n    width: ${wi}px;\n    height: ${he}px;\n    background: #000;\n  `)\n  \n  \n  let parent = `\n    position: relative;\n    width: 400px;\n    height: 400px;\n  `\n  \n  return h(\"div\", {style: parent},  h(\"div\", {style: one, ref: one_ref}))\n}\n  ",
      "cursor": 836
    },
    {
      "type": "group",
      "id": "uwth0c",
      "active": false,
      "focus": false,
      "start": 3420,
      "drag_x": 5768.468109408692,
      "drag_y": 957,
      "drag_w": 600,
      "drag_h": 1200,
      "output": "",
      "blocks": []
    },
    {
      "type": "code",
      "id": "v2a3aw",
      "start": 3420,
      "drag_x": 2917.01058745169,
      "drag_y": 1342.7170427596486,
      "focused": false,
      "output": "/**\n@typedef {Object} category \n@property {string} category.title\n@property {Array<string>} category.files\n\n@param {Array<category>} categories \n*/\n\nfunction init_structure(categories) {\n  let struct = {}\n  \n\n  categories.forEach((category, c_index) => {\n    let elements = category.files.map((file, e_index) => {\n      let element = {\n        // based on c_index and e_index\n        position: {\n          x: e_index * .1, \n          y: 0,\n          z: e_index* -.1,\n        },\n\n        // to attach to\n        three: undefined,\n\n        // update fn\n        tick: function(){\n          if (this.three){\n            // check three positon with this position\n            // if not eq, update three position\n            if (!eq(this.three.position, this.position)){\n              this.three.position.x = this.position.x\n              this.three.position.y = this.position.y\n              this.three.position.z = this.position.z\n            }\n          }\n          \n        }\n      }\n      create_image_plane(file, element)\n      \n      return element\n    })\n    struct[category.title] = elements\n  })\n\n  console.log(struct)\n  return struct\n  \n  \n  // will accept categories (dir) and textures (files)\n  // will make a data structure\n  // based on data strucutre spawn planes for image\n  // plane maker will attach itself to ref we pass\n  // to elem instance or whatever\n\n  // data structure of each element will have a tick fn\n  // every update cycle this is called\n  \n}\n\n\n\n\n\n\n",
      "cursor": 0,
      "active": false,
      "focus": false,
      "drag_w": 600,
      "drag_h": 1200
    },
    {
      "type": "code",
      "id": "q7j8vc",
      "start": 4895,
      "drag_x": 5079.281801538619,
      "drag_y": 756.7964766665527,
      "focused": false,
      "output": "\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "cursor": 0,
      "active": false,
      "focus": false,
      "drag_w": 600,
      "drag_h": 1200
    },
    {
      "type": "code",
      "id": "mf4rl",
      "start": 4908,
      "drag_x": 4393.437441085362,
      "drag_y": 2400.2884292730214,
      "focused": false,
      "output": "\nfunction create_image_plane(image, element){\n  loader.load(image, function(texture){\n    let w = texture.source.data.naturalWidth\n    let h = texture.source.data.naturalHeight\n  \n    let aspect = w/h\n    let aw = 5\n    let ah = aw / aspect \n      \n    const geometry = new THREE.PlaneGeometry(aw, ah);\n    \n    const material = new THREE.MeshBasicMaterial({ \n        map: texture,\n        opacity: .45,\n        transparent: true\n    });\n  \n    \n    // Create mesh\n    const plane = new THREE.Mesh(geometry, material);\n    \n    // Scale the plane to match image dimensions\n    const scale = new THREE.Vector3();\n    texture.image.addEventListener('load', () => {\n        scale.set(texture.image.width, texture.image.height, 1);\n        plane.scale.copy(scale);\n    });\n  \n    scene.add(plane)\n    element.three = plane\n  });\n}\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "cursor": 0,
      "active": false,
      "focus": false,
      "drag_w": 600,
      "drag_h": 1200
    }
  ],
  "output": "",
  "properties": {
    "panzoom": {
      "initialX": -2376.340872404944,
      "initialY": -440.04468542469465,
      "initialZoom": 0.5643510208341206
    }
  }
}