{
  "blocks": [
    {
      "type": "basic",
      "active": false
    },
    {
      "type": "code",
      "active": true,
      "focus": false,
      "focused": false,
      "output": "// -------------\n// Solid Imports\n// -------------\nimport {\n\tbatch,\n\teach,\n\teff_on,\n\th,\n\tmem,\n\tmounted,\n\tproduce,\n\trender,\n\tsig,\n\tstore,\n} from \"/lib/solid/monke.js\";\n\nimport { Keymanager } from \"/lib/keymanager.js\";\n\n// -------------\n// Codemirror Imports\n// -------------\nimport {\n\tbasicSetup,\n\tEditorState,\n\tEditorView,\n\tjavascript,\n\tkeymap,\n\tVim,\n\tvim,\n} from \"/lib/codemirror/bundled.js\";\n\n// -------------\n// UTILITIES\n// -------------\nlet CURRENT_PATH = \"\";\nconst save_path = \"new_editor.json\";\nconst m = () => document.querySelector(\"iframe\")?.contentDocument.M;\nconst uid = () => Math.random().toString(36).substring(7);\n\nfunction defer(fn) {\n\tsetTimeout(fn, 10);\n}\n\nfunction eval_code(code) {\n\treturn eval(`\"use strict\";(${code})`);\n}\n\n// =============\n// CORE\n// =============\nclass RendererList {\n\tconstructor() {\n\t\tconst [renderers, set_renderers] = store({});\n\t\tthis.renderers = renderers;\n\t\tthis.set_renderers = set_renderers;\n\t}\n\n\tregister(type, fn) {\n\t\tthis.set_renderers(type, fn);\n\t}\n\n\t/**\n\t * @param {name} string\n\t * @returns {() => View}\n\t */\n\tfind(type) {\n\t\tconst fn_str = this.renderers[type];\n\t\tconst fn = eval_code(fn_str);\n\t\tif (typeof fn == \"function\") return fn;\n\t\telse throw new Error(\"invalid renderer\");\n\t}\n}\n\nclass State {\n\tconstructor({ type, blocks, parent, cursor, id }) {\n\t\tconst _blocks = blocks ? blocks : [];\n\t\tconst _type = type ? type : \"default\";\n\t\tconst _id = id ? id : uid();\n\n\t\tconst [model, update] = store({\n\t\t\tblocks: _blocks,\n\t\t\toutput: \"\",\n\t\t});\n\n\t\tthis.id = _id;\n\t\tthis.type = _type;\n\t\tthis.model = model;\n\t\tthis.update = (...args) => update(...args);\n\n\t\tthis.parent = parent;\n\t\tthis.cursor = sig(cursor || -1);\n\t}\n\n\tget blocks() {\n\t\treturn this.model.blocks;\n\t}\n\n\tupdate_blocks(...args) {\n\t\treturn this.update(\"blocks\", ...args);\n\t}\n\n\tlen() {\n\t\treturn this.model.blocks.length;\n\t}\n\n\tnext() {\n\t\tthis.len() > this.cursor() + 1\n\t\t\t? this.cursor.set(this.cursor() + 1)\n\t\t\t: this.cursor.set(0);\n\t}\n\n\tprev() {\n\t\tthis.cursor() > 0\n\t\t\t? this.cursor.set(this.cursor() - 1)\n\t\t\t: this.cursor.set(this.len() - 1);\n\t}\n\n\twrite() {\n\t\tconst queue = this.model.blocks.map((comp) => comp.write);\n\t\tconst run = (code, index) =>\n\t\t\t\"function\" == typeof code\n\t\t\t\t? this.update_blocks(index, produce((el) => code(el)))\n\t\t\t\t: null;\n\n\t\tbatch(() => queue.forEach(run));\n\t\tthis.output = this.model.blocks.map((e) => e.output).join(\"\\n\");\n\t}\n\n\tload(path) {\n\t\tfetch(\"/fs/\" + path).then((res) => res.json())\n\t\t\t.then((res) => {\n\t\t\t\tres.blocks\n\t\t\t\t\t? this.update(\"blocks\", res.blocks)\n\t\t\t\t\t: console.log(\"no blocks\");\n\t\t\t\tCURRENT_PATH = path;\n\t\t\t});\n\t}\n\n\toverwrite(path) {\n\t\tconsole.log(\"overwriting\", path);\n\n\t\tconst body = {\n\t\t\tcontent: JSON.stringify(this.model, null, 2),\n\t\t};\n\n\t\tfetch(\"/fs/\" + path, {\n\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\tmethod: \"PUT\",\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\t}\n\n\tcreate_new(path) {\n\t\tconst body = {\n\t\t\tcontent: JSON.stringify(this.model, null, 2),\n\t\t};\n\t\tfetch(\"/fs/\" + path, {\n\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\tmethod: \"POST\",\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\t}\n\n\tsave(path) {\n\t\tfetch(\"/exists/\" + path).then((res) => res.json()).then((res) =>\n\t\t\tres.exists ? this.overwrite(path) : this.create_new(path)\n\t\t);\n\t}\n\n\toutput_file(path) {\n\t\tconst body = {\n\t\t\tcontent: iframe(),\n\t\t};\n\n\t\tfetch(\"/fs/\" + path, {\n\t\t\theaders: { \"Content-Type\": \"application/json\" },\n\t\t\tmethod: \"PUT\",\n\t\t\tbody: JSON.stringify(body),\n\t\t});\n\t}\n}\n\nclass Editor {\n\tconstructor({ state, components, renderer }) {\n\t\tif (!renderer) throw Error(\"Need a renderer\");\n\t\tthis.renderer = renderer;\n\t\tthis.state = state ? state : new State({ type: \"RootGroup\" });\n\t\tthis.renderers = components ? components : new RendererList();\n\t}\n\n\tregister(type, fn_str) {\n\t\tthis.renderers.register(type, fn_str);\n\t}\n\n\tbind(element, setter) {\n\t\tconst render = this.renderer;\n\t\tconst component = render(element, this.state);\n\n\t\tsetter((el) => {\n\t\t\tObject\n\t\t\t\t.entries(component)\n\t\t\t\t.forEach(([key, value]) => el[key] = value);\n\t\t});\n\n\t\treturn component.render;\n\t}\n\n\trender() {\n\t\tconst setter = (fn) => this.state.update(produce(fn));\n\t\treturn this.bind(this.state, setter);\n\t}\n}\n\nclass Positioner {\n\tconstructor(x, y, w, h, unit = \"v\", position = \"fixed\") {\n\t\tthis.x = sig(x || 0);\n\t\tthis.y = sig(y || 0);\n\t\tthis.w = sig(w || 0);\n\t\tthis.h = sig(h || 0);\n\n\t\tthis.unit = unit;\n\t\tthis.position = position;\n\n\t\tthis.style = mem(() => {\n\t\t\tconst v = this.unit == \"v\" ? \"vh\" : this.unit;\n\t\t\tconst h = this.unit == \"v\" ? \"vw\" : this.unit;\n\n\t\t\treturn `\n\t\t\t\tposition: ${this.position};\n\t\t\t\ttop: ${this.y() + v};\n\t\t\t\tleft: ${this.x() + h};\n\t\t\t\theight: ${this.h() + v};\n\t\t\t\twidth: ${this.w() + h};\n\t\t\t`;\n\t\t});\n\t}\n\n\tget css() {\n\t\treturn this.style;\n\t}\n}\n\nfunction state_utils(state) {\n\tconst find_focused = () => state.blocks.find((e) => e.focus);\n\tconst set_current_active = () => {\n\t\tif (!state.blocks[state.cursor()]) return;\n\t\tstate.update_blocks(state.cursor(), \"active\", true);\n\t\tstate.update_blocks((_, i) => i != state.cursor(), \"active\", false);\n\t};\n\n\tconst set_current_focus = () => {\n\t\tif (!state.blocks[state.cursor()]) return;\n\t\tconst current = state.blocks[state.cursor()];\n\t\tstate.update_blocks(state.cursor(), \"focus\", true);\n\t\tif (current.onfocus) current.onfocus();\n\t};\n\n\tconst unfocus_current = () => {\n\t\tconst current = find_focused(state);\n\t\tstate.update_blocks((e) => e.focus, \"focus\", false);\n\t\tif (current.onunfocus) current.onunfocus();\n\t};\n\treturn {\n\t\tfind_focused,\n\t\tset_current_active,\n\t\tset_current_focus,\n\t\tunfocus_current,\n\t};\n}\n\n// =============\n// Root Renderer\n// =============\n/**\n * @param {State} state\n */\nfunction RootRenderer(el, state) {\n\tconst blocks = el.blocks || [];\n\tstate = state || new State({ blocks });\n\n\t// add these to state as prototype?\n\tconst {\n\t\tset_current_focus,\n\t\tset_current_active,\n\t\tfind_focused,\n\t\tunfocus_current,\n\t} = state_utils(state);\n\n\teff_on(state.cursor, set_current_active);\n\n\tconst child_style = (child) => {\n\t\tconst border_is = mem(() => child.active && !child.focus);\n\t\tconst shadow_is = mem(() => child.focus);\n\n\t\tconst border = mem(() => border_is() ? \"border: 1px solid grey\" : \"\");\n\t\tconst box_shadow = mem(() =>\n\t\t\tshadow_is() ? \"box-shadow: 0 0 25px 5px rgba(0,0,0,.1)\" : \"\"\n\t\t);\n\n\t\treturn mem(() => [border(), box_shadow()].join(\";\"));\n\t};\n\n\tconst bind = (child, index) => {\n\t\tif (!child) return;\n\t\tconst item = editor.renderers.find(child.type);\n\t\tif (!(typeof item == \"function\")) return;\n\n\t\tconst setter = (...args) => state.update_blocks(index(), ...args);\n\t\tconst controller = { set_self: setter };\n\t\tconst component = item(child, index, controller);\n\n\t\tsetter(produce((block) => {\n\t\t\tObject\n\t\t\t\t.entries(component)\n\t\t\t\t.forEach(([key, value]) => block[key] = value);\n\t\t}));\n\n\t\tconst style = child_style(child);\n\t\treturn h(\"div\", { style: style }, component.render);\n\t};\n\n\tconst keys = new Keymanager();\n\n\tkeys.on(\"Escape\", unfocus_current);\n\tkeys.on(\"Enter\", set_current_focus);\n\tkeys.on(\"shift+c\", (_) => add_widget({ type: \"code\" }));\n\tkeys.on(\"shift+a\", (_) => add_widget({ type: \"basic\" }));\n\tkeys.on(\"cmd+m\", (_) => state.save(save_path));\n\tkeys.on(\"cmd+l\", (_) => state.load(save_path));\n\tkeys.on(\"cmd+o\", (_) => console.log('ok'));\n\tkeys.on(\"cmd+b\", (_) => state.load(SOURCE_PATH));\n\tkeys.on(\"ctrl+s\", (_) => state.write());\n\tkeys.on(\"j\", (_) => state.next());\n\tkeys.on(\"k\", (_) => state.prev());\n\n\tconst handle_keys = (e) => {\n\t\tconst focused = find_focused();\n\n\t\tif (focused && e.key != \"Escape\") {\n\t\t\tif (focused.onkeydown) focused.onkeydown(e);\n\t\t\tconsole.log(\"returning\");\n\t\t\treturn;\n\t\t}\n\n\t\tkeys.event(e);\n\t};\n\n\tconst write = (el) => {\n\t\tstate.write();\n\t\tlet output = state.blocks.map((child) => child.output).join(\"\\n\");\n\t\tstate.blocks.forEach((child) => console.log(child));\n\t\tel.output = output;\n\t\tel.blocks = state.blocks;\n\t};\n\n\tconst add_widget = (opts) =>\n\t\tstate.update_blocks(produce((e) => e.push(opts)));\n\n\treturn {\n\t\trender: () => h(\"div.group\", () => each(() => state.blocks, bind)),\n\t\tonkeydown: handle_keys,\n\t\twrite: (el) => write(el),\n\t};\n}\n\nconst editor = new Editor({ renderer: RootRenderer });\n\n/**\n * @typedef {Object} View\n *\n * @property {(el) => void} write\n * @property {() => any[] | any} render\n *\n * @property {() => void} [onkeydown]\n * @property {() => void} [onfocus]\n * @property {() => void} [onunfocus]\n */\nwindow.onload = () => {\n\twindow.addEventListener(\"keydown\", (e) => {\n\t\tif (editor.state.model.onkeydown) {\n\t\t\teditor.state.model.onkeydown(e);\n\t\t}\n\t});\n};\n\neff_on(\n\t() => editor.state.blocks,\n\t() => console.log(editor.state.blocks.map((e) => e.output).join(\"\\n\")),\n);\n\nconst f = \"/\";\nconst iframe = mem(() =>\n\t`<script type=\"module\"> import {mut} from \"/lib/solid/monke.js\";\n\t\t\tconst M = mut({});\n\t\t\tconst SOURCE_PATH = \"\"\n\t\t\tdocument.M = M;\n\t\t\t${editor.state.blocks.map((e) => e.output).join(\"\\n\")}\n\t\t<${f}script>\n`\n);\n\nconst Root = () => {\n\tconst iframe_pos = new Positioner(50, 0, 50, 100);\n\tconst editor_pos = new Positioner(0, 0, 50, 100);\n\n\tconst iframe_style = iframe_pos.css;\n\tconst editor_style = mem(() => \"overflow-y: scroll;\" + editor_pos.css());\n\n\treturn h(\"div\", [\n\t\th(\"div.editor\", { style: editor_style }, editor.render()),\n\t\th(\"iframe.iframe\", { srcdoc: iframe, style: iframe_style }),\n\t]);\n};\n\n// ------------------------\n// BASIC ELEMENT\n// ------------------------\nconst basic = (el) => {\n\tconst name = el.name || \"unnamed\";\n\treturn ({ render: () => h(\"p\", \"basic \", name) });\n};\neditor.register(\"basic\", basic.toString());\n\n// ------------------------\n// CODEMIRROR ELEMENT\n// ------------------------\nfunction code_element(state) {\n\tconst code = mem(() => state?.output ? state?.output : \"\");\n\tconst id = uid();\n\tlet save, focus;\n\n\tVim.defineEx(\"write\", \"w\", () => {\n\t\teditor.state.write();\n\t});\n\tconst render = () => {\n\t\t{\n\t\t\tmounted(() => {\n\t\t\t\tconst editor = make_code_mirror(code(), id);\n\t\t\t\tfocus = () => {\n\t\t\t\t\tconsole.log(\"called\");\n\t\t\t\t\tsetTimeout(() => editor.focus(), 100);\n\t\t\t\t};\n\n\t\t\t\tsave = function (el) {\n\t\t\t\t\tconst text = cm_flatten_tree(editor.state.doc).join(\"\\n\");\n\t\t\t\t\tconsole.log(\"text\", text);\n\t\t\t\t\tel.focused = editor.hasFocus;\n\t\t\t\t\tel.output = text;\n\t\t\t\t\tel.cursor = editor.state.selection.ranges[0].from;\n\t\t\t\t};\n\n\t\t\t\tdefer(function () {\n\t\t\t\t\tif (state.cursor && state.focused) {\n\t\t\t\t\t\tconst selection = { anchor: state.cursor, head: state.cursor };\n\t\t\t\t\t\teditor.focus();\n\t\t\t\t\t\teditor.dispatch({ selection });\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\n\t\t\treturn h(\"div\", { class: \"editor-\" + id });\n\t\t}\n\t};\n\n\treturn ({\n\t\trender: render,\n\t\tonfocus: () => focus(),\n\t\twrite: (...args) => save(...args),\n\t});\n}\neditor.register(\"code\", code_element.toString());\n\n// ------------------------\n// CODEMIRROR UTILS\n// ------------------------\nfunction make_code_mirror(source, id) {\n\tconst element = document.querySelector(\".editor-\" + id);\n\tconst state = {\n\t\tdoc: source,\n\t\textensions: [\n\t\t\tvim(),\n\t\t\tbasicSetup,\n\t\t\tjavascript(),\n\n\t\t\tkeymap.of([\n\t\t\t\t{\n\t\t\t\t\tkey: \"Escape\",\n\t\t\t\t\trun: () => {\n\t\t\t\t\t\teditor.contentDOM.blur();\n\t\t\t\t\t\twindow.getSelection()?.removeAllRanges();\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t]),\n\t\t],\n\t};\n\n\tconst editor = new EditorView({\n\t\tparent: element,\n\t\tstate: EditorState.create(state),\n\t});\n\n\treturn editor;\n}\n\nconst cm_flatten_tree = (doc) => {\n\tlet text = [];\n\n\tif (doc.children) {\n\t\tdoc.children.forEach((child) => {\n\t\t\ttext = text.concat(cm_flatten_tree(child));\n\t\t});\n\t} else if (doc.text) return doc.text;\n\n\treturn text;\n};\n\nrender(Root, document.body);\ndocument.body.style.background=\"pink\"\n",
      "cursor": 493
    }
  ],
  "output": ""
}